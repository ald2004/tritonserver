// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_model_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_model_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_model_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_model_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[46]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_model_5fconfig_2eproto;
namespace inference {
class BatchInput;
class BatchInputDefaultTypeInternal;
extern BatchInputDefaultTypeInternal _BatchInput_default_instance_;
class BatchOutput;
class BatchOutputDefaultTypeInternal;
extern BatchOutputDefaultTypeInternal _BatchOutput_default_instance_;
class ModelConfig;
class ModelConfigDefaultTypeInternal;
extern ModelConfigDefaultTypeInternal _ModelConfig_default_instance_;
class ModelConfig_CcModelFilenamesEntry_DoNotUse;
class ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_CcModelFilenamesEntry_DoNotUseDefaultTypeInternal _ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_;
class ModelConfig_MetricTagsEntry_DoNotUse;
class ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_MetricTagsEntry_DoNotUseDefaultTypeInternal _ModelConfig_MetricTagsEntry_DoNotUse_default_instance_;
class ModelConfig_ParametersEntry_DoNotUse;
class ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal _ModelConfig_ParametersEntry_DoNotUse_default_instance_;
class ModelDynamicBatching;
class ModelDynamicBatchingDefaultTypeInternal;
extern ModelDynamicBatchingDefaultTypeInternal _ModelDynamicBatching_default_instance_;
class ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse;
class ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal;
extern ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUseDefaultTypeInternal _ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_;
class ModelEnsembling;
class ModelEnsemblingDefaultTypeInternal;
extern ModelEnsemblingDefaultTypeInternal _ModelEnsembling_default_instance_;
class ModelEnsembling_Step;
class ModelEnsembling_StepDefaultTypeInternal;
extern ModelEnsembling_StepDefaultTypeInternal _ModelEnsembling_Step_default_instance_;
class ModelEnsembling_Step_InputMapEntry_DoNotUse;
class ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal;
extern ModelEnsembling_Step_InputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_;
class ModelEnsembling_Step_OutputMapEntry_DoNotUse;
class ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal;
extern ModelEnsembling_Step_OutputMapEntry_DoNotUseDefaultTypeInternal _ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_;
class ModelInput;
class ModelInputDefaultTypeInternal;
extern ModelInputDefaultTypeInternal _ModelInput_default_instance_;
class ModelInstanceGroup;
class ModelInstanceGroupDefaultTypeInternal;
extern ModelInstanceGroupDefaultTypeInternal _ModelInstanceGroup_default_instance_;
class ModelOperations;
class ModelOperationsDefaultTypeInternal;
extern ModelOperationsDefaultTypeInternal _ModelOperations_default_instance_;
class ModelOptimizationPolicy;
class ModelOptimizationPolicyDefaultTypeInternal;
extern ModelOptimizationPolicyDefaultTypeInternal _ModelOptimizationPolicy_default_instance_;
class ModelOptimizationPolicy_Cuda;
class ModelOptimizationPolicy_CudaDefaultTypeInternal;
extern ModelOptimizationPolicy_CudaDefaultTypeInternal _ModelOptimizationPolicy_Cuda_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec;
class ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpecDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse;
class ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound;
class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse;
class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_;
class ModelOptimizationPolicy_Cuda_GraphSpec_Shape;
class ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal;
extern ModelOptimizationPolicy_Cuda_GraphSpec_ShapeDefaultTypeInternal _ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_;
class ModelOptimizationPolicy_ExecutionAccelerators;
class ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal;
extern ModelOptimizationPolicy_ExecutionAcceleratorsDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_default_instance_;
class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator;
class ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal;
extern ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_;
class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse;
class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUseDefaultTypeInternal _ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_;
class ModelOptimizationPolicy_Graph;
class ModelOptimizationPolicy_GraphDefaultTypeInternal;
extern ModelOptimizationPolicy_GraphDefaultTypeInternal _ModelOptimizationPolicy_Graph_default_instance_;
class ModelOptimizationPolicy_PinnedMemoryBuffer;
class ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal;
extern ModelOptimizationPolicy_PinnedMemoryBufferDefaultTypeInternal _ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_;
class ModelOutput;
class ModelOutputDefaultTypeInternal;
extern ModelOutputDefaultTypeInternal _ModelOutput_default_instance_;
class ModelParameter;
class ModelParameterDefaultTypeInternal;
extern ModelParameterDefaultTypeInternal _ModelParameter_default_instance_;
class ModelQueuePolicy;
class ModelQueuePolicyDefaultTypeInternal;
extern ModelQueuePolicyDefaultTypeInternal _ModelQueuePolicy_default_instance_;
class ModelRateLimiter;
class ModelRateLimiterDefaultTypeInternal;
extern ModelRateLimiterDefaultTypeInternal _ModelRateLimiter_default_instance_;
class ModelRateLimiter_Resource;
class ModelRateLimiter_ResourceDefaultTypeInternal;
extern ModelRateLimiter_ResourceDefaultTypeInternal _ModelRateLimiter_Resource_default_instance_;
class ModelSequenceBatching;
class ModelSequenceBatchingDefaultTypeInternal;
extern ModelSequenceBatchingDefaultTypeInternal _ModelSequenceBatching_default_instance_;
class ModelSequenceBatching_Control;
class ModelSequenceBatching_ControlDefaultTypeInternal;
extern ModelSequenceBatching_ControlDefaultTypeInternal _ModelSequenceBatching_Control_default_instance_;
class ModelSequenceBatching_ControlInput;
class ModelSequenceBatching_ControlInputDefaultTypeInternal;
extern ModelSequenceBatching_ControlInputDefaultTypeInternal _ModelSequenceBatching_ControlInput_default_instance_;
class ModelSequenceBatching_StrategyDirect;
class ModelSequenceBatching_StrategyDirectDefaultTypeInternal;
extern ModelSequenceBatching_StrategyDirectDefaultTypeInternal _ModelSequenceBatching_StrategyDirect_default_instance_;
class ModelSequenceBatching_StrategyOldest;
class ModelSequenceBatching_StrategyOldestDefaultTypeInternal;
extern ModelSequenceBatching_StrategyOldestDefaultTypeInternal _ModelSequenceBatching_StrategyOldest_default_instance_;
class ModelTensorReshape;
class ModelTensorReshapeDefaultTypeInternal;
extern ModelTensorReshapeDefaultTypeInternal _ModelTensorReshape_default_instance_;
class ModelTransactionPolicy;
class ModelTransactionPolicyDefaultTypeInternal;
extern ModelTransactionPolicyDefaultTypeInternal _ModelTransactionPolicy_default_instance_;
class ModelVersionPolicy;
class ModelVersionPolicyDefaultTypeInternal;
extern ModelVersionPolicyDefaultTypeInternal _ModelVersionPolicy_default_instance_;
class ModelVersionPolicy_All;
class ModelVersionPolicy_AllDefaultTypeInternal;
extern ModelVersionPolicy_AllDefaultTypeInternal _ModelVersionPolicy_All_default_instance_;
class ModelVersionPolicy_Latest;
class ModelVersionPolicy_LatestDefaultTypeInternal;
extern ModelVersionPolicy_LatestDefaultTypeInternal _ModelVersionPolicy_Latest_default_instance_;
class ModelVersionPolicy_Specific;
class ModelVersionPolicy_SpecificDefaultTypeInternal;
extern ModelVersionPolicy_SpecificDefaultTypeInternal _ModelVersionPolicy_Specific_default_instance_;
class ModelWarmup;
class ModelWarmupDefaultTypeInternal;
extern ModelWarmupDefaultTypeInternal _ModelWarmup_default_instance_;
class ModelWarmup_Input;
class ModelWarmup_InputDefaultTypeInternal;
extern ModelWarmup_InputDefaultTypeInternal _ModelWarmup_Input_default_instance_;
class ModelWarmup_InputsEntry_DoNotUse;
class ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal;
extern ModelWarmup_InputsEntry_DoNotUseDefaultTypeInternal _ModelWarmup_InputsEntry_DoNotUse_default_instance_;
}  // namespace inference
PROTOBUF_NAMESPACE_OPEN
template<> ::inference::BatchInput* Arena::CreateMaybeMessage<::inference::BatchInput>(Arena*);
template<> ::inference::BatchOutput* Arena::CreateMaybeMessage<::inference::BatchOutput>(Arena*);
template<> ::inference::ModelConfig* Arena::CreateMaybeMessage<::inference::ModelConfig>(Arena*);
template<> ::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelConfig_CcModelFilenamesEntry_DoNotUse>(Arena*);
template<> ::inference::ModelConfig_MetricTagsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelConfig_MetricTagsEntry_DoNotUse>(Arena*);
template<> ::inference::ModelConfig_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelConfig_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelDynamicBatching* Arena::CreateMaybeMessage<::inference::ModelDynamicBatching>(Arena*);
template<> ::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse>(Arena*);
template<> ::inference::ModelEnsembling* Arena::CreateMaybeMessage<::inference::ModelEnsembling>(Arena*);
template<> ::inference::ModelEnsembling_Step* Arena::CreateMaybeMessage<::inference::ModelEnsembling_Step>(Arena*);
template<> ::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelEnsembling_Step_InputMapEntry_DoNotUse>(Arena*);
template<> ::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelEnsembling_Step_OutputMapEntry_DoNotUse>(Arena*);
template<> ::inference::ModelInput* Arena::CreateMaybeMessage<::inference::ModelInput>(Arena*);
template<> ::inference::ModelInstanceGroup* Arena::CreateMaybeMessage<::inference::ModelInstanceGroup>(Arena*);
template<> ::inference::ModelOperations* Arena::CreateMaybeMessage<::inference::ModelOperations>(Arena*);
template<> ::inference::ModelOptimizationPolicy* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape>(Arena*);
template<> ::inference::ModelOptimizationPolicy_ExecutionAccelerators* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators>(Arena*);
template<> ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator>(Arena*);
template<> ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse>(Arena*);
template<> ::inference::ModelOptimizationPolicy_Graph* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_Graph>(Arena*);
template<> ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* Arena::CreateMaybeMessage<::inference::ModelOptimizationPolicy_PinnedMemoryBuffer>(Arena*);
template<> ::inference::ModelOutput* Arena::CreateMaybeMessage<::inference::ModelOutput>(Arena*);
template<> ::inference::ModelParameter* Arena::CreateMaybeMessage<::inference::ModelParameter>(Arena*);
template<> ::inference::ModelQueuePolicy* Arena::CreateMaybeMessage<::inference::ModelQueuePolicy>(Arena*);
template<> ::inference::ModelRateLimiter* Arena::CreateMaybeMessage<::inference::ModelRateLimiter>(Arena*);
template<> ::inference::ModelRateLimiter_Resource* Arena::CreateMaybeMessage<::inference::ModelRateLimiter_Resource>(Arena*);
template<> ::inference::ModelSequenceBatching* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching>(Arena*);
template<> ::inference::ModelSequenceBatching_Control* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_Control>(Arena*);
template<> ::inference::ModelSequenceBatching_ControlInput* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_ControlInput>(Arena*);
template<> ::inference::ModelSequenceBatching_StrategyDirect* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_StrategyDirect>(Arena*);
template<> ::inference::ModelSequenceBatching_StrategyOldest* Arena::CreateMaybeMessage<::inference::ModelSequenceBatching_StrategyOldest>(Arena*);
template<> ::inference::ModelTensorReshape* Arena::CreateMaybeMessage<::inference::ModelTensorReshape>(Arena*);
template<> ::inference::ModelTransactionPolicy* Arena::CreateMaybeMessage<::inference::ModelTransactionPolicy>(Arena*);
template<> ::inference::ModelVersionPolicy* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy>(Arena*);
template<> ::inference::ModelVersionPolicy_All* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy_All>(Arena*);
template<> ::inference::ModelVersionPolicy_Latest* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy_Latest>(Arena*);
template<> ::inference::ModelVersionPolicy_Specific* Arena::CreateMaybeMessage<::inference::ModelVersionPolicy_Specific>(Arena*);
template<> ::inference::ModelWarmup* Arena::CreateMaybeMessage<::inference::ModelWarmup>(Arena*);
template<> ::inference::ModelWarmup_Input* Arena::CreateMaybeMessage<::inference::ModelWarmup_Input>(Arena*);
template<> ::inference::ModelWarmup_InputsEntry_DoNotUse* Arena::CreateMaybeMessage<::inference::ModelWarmup_InputsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace inference {

enum ModelInstanceGroup_Kind : int {
  ModelInstanceGroup_Kind_KIND_AUTO = 0,
  ModelInstanceGroup_Kind_KIND_GPU = 1,
  ModelInstanceGroup_Kind_KIND_CPU = 2,
  ModelInstanceGroup_Kind_KIND_MODEL = 3,
  ModelInstanceGroup_Kind_ModelInstanceGroup_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelInstanceGroup_Kind_ModelInstanceGroup_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelInstanceGroup_Kind_IsValid(int value);
constexpr ModelInstanceGroup_Kind ModelInstanceGroup_Kind_Kind_MIN = ModelInstanceGroup_Kind_KIND_AUTO;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup_Kind_Kind_MAX = ModelInstanceGroup_Kind_KIND_MODEL;
constexpr int ModelInstanceGroup_Kind_Kind_ARRAYSIZE = ModelInstanceGroup_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_Kind_descriptor();
template<typename T>
inline const std::string& ModelInstanceGroup_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelInstanceGroup_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelInstanceGroup_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelInstanceGroup_Kind_descriptor(), enum_t_value);
}
inline bool ModelInstanceGroup_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelInstanceGroup_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelInstanceGroup_Kind>(
    ModelInstanceGroup_Kind_descriptor(), name, value);
}
enum ModelInput_Format : int {
  ModelInput_Format_FORMAT_NONE = 0,
  ModelInput_Format_FORMAT_NHWC = 1,
  ModelInput_Format_FORMAT_NCHW = 2,
  ModelInput_Format_ModelInput_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelInput_Format_ModelInput_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelInput_Format_IsValid(int value);
constexpr ModelInput_Format ModelInput_Format_Format_MIN = ModelInput_Format_FORMAT_NONE;
constexpr ModelInput_Format ModelInput_Format_Format_MAX = ModelInput_Format_FORMAT_NCHW;
constexpr int ModelInput_Format_Format_ARRAYSIZE = ModelInput_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInput_Format_descriptor();
template<typename T>
inline const std::string& ModelInput_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelInput_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelInput_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelInput_Format_descriptor(), enum_t_value);
}
inline bool ModelInput_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelInput_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelInput_Format>(
    ModelInput_Format_descriptor(), name, value);
}
enum BatchInput_Kind : int {
  BatchInput_Kind_BATCH_ELEMENT_COUNT = 0,
  BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT = 1,
  BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO = 2,
  BatchInput_Kind_BATCH_MAX_ELEMENT_COUNT_AS_SHAPE = 3,
  BatchInput_Kind_BatchInput_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BatchInput_Kind_BatchInput_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BatchInput_Kind_IsValid(int value);
constexpr BatchInput_Kind BatchInput_Kind_Kind_MIN = BatchInput_Kind_BATCH_ELEMENT_COUNT;
constexpr BatchInput_Kind BatchInput_Kind_Kind_MAX = BatchInput_Kind_BATCH_MAX_ELEMENT_COUNT_AS_SHAPE;
constexpr int BatchInput_Kind_Kind_ARRAYSIZE = BatchInput_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchInput_Kind_descriptor();
template<typename T>
inline const std::string& BatchInput_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatchInput_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatchInput_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatchInput_Kind_descriptor(), enum_t_value);
}
inline bool BatchInput_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatchInput_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatchInput_Kind>(
    BatchInput_Kind_descriptor(), name, value);
}
enum BatchOutput_Kind : int {
  BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE = 0,
  BatchOutput_Kind_BatchOutput_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BatchOutput_Kind_BatchOutput_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BatchOutput_Kind_IsValid(int value);
constexpr BatchOutput_Kind BatchOutput_Kind_Kind_MIN = BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE;
constexpr BatchOutput_Kind BatchOutput_Kind_Kind_MAX = BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE;
constexpr int BatchOutput_Kind_Kind_ARRAYSIZE = BatchOutput_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchOutput_Kind_descriptor();
template<typename T>
inline const std::string& BatchOutput_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatchOutput_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatchOutput_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatchOutput_Kind_descriptor(), enum_t_value);
}
inline bool BatchOutput_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatchOutput_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatchOutput_Kind>(
    BatchOutput_Kind_descriptor(), name, value);
}
enum ModelOptimizationPolicy_ModelPriority : int {
  ModelOptimizationPolicy_ModelPriority_PRIORITY_DEFAULT = 0,
  ModelOptimizationPolicy_ModelPriority_PRIORITY_MAX = 1,
  ModelOptimizationPolicy_ModelPriority_PRIORITY_MIN = 2,
  ModelOptimizationPolicy_ModelPriority_ModelOptimizationPolicy_ModelPriority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelOptimizationPolicy_ModelPriority_ModelOptimizationPolicy_ModelPriority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelOptimizationPolicy_ModelPriority_IsValid(int value);
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy_ModelPriority_ModelPriority_MIN = ModelOptimizationPolicy_ModelPriority_PRIORITY_DEFAULT;
constexpr ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy_ModelPriority_ModelPriority_MAX = ModelOptimizationPolicy_ModelPriority_PRIORITY_MIN;
constexpr int ModelOptimizationPolicy_ModelPriority_ModelPriority_ARRAYSIZE = ModelOptimizationPolicy_ModelPriority_ModelPriority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelOptimizationPolicy_ModelPriority_descriptor();
template<typename T>
inline const std::string& ModelOptimizationPolicy_ModelPriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelOptimizationPolicy_ModelPriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelOptimizationPolicy_ModelPriority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelOptimizationPolicy_ModelPriority_descriptor(), enum_t_value);
}
inline bool ModelOptimizationPolicy_ModelPriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelOptimizationPolicy_ModelPriority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelOptimizationPolicy_ModelPriority>(
    ModelOptimizationPolicy_ModelPriority_descriptor(), name, value);
}
enum ModelQueuePolicy_TimeoutAction : int {
  ModelQueuePolicy_TimeoutAction_REJECT = 0,
  ModelQueuePolicy_TimeoutAction_DELAY = 1,
  ModelQueuePolicy_TimeoutAction_ModelQueuePolicy_TimeoutAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelQueuePolicy_TimeoutAction_ModelQueuePolicy_TimeoutAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelQueuePolicy_TimeoutAction_IsValid(int value);
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy_TimeoutAction_TimeoutAction_MIN = ModelQueuePolicy_TimeoutAction_REJECT;
constexpr ModelQueuePolicy_TimeoutAction ModelQueuePolicy_TimeoutAction_TimeoutAction_MAX = ModelQueuePolicy_TimeoutAction_DELAY;
constexpr int ModelQueuePolicy_TimeoutAction_TimeoutAction_ARRAYSIZE = ModelQueuePolicy_TimeoutAction_TimeoutAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelQueuePolicy_TimeoutAction_descriptor();
template<typename T>
inline const std::string& ModelQueuePolicy_TimeoutAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelQueuePolicy_TimeoutAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelQueuePolicy_TimeoutAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelQueuePolicy_TimeoutAction_descriptor(), enum_t_value);
}
inline bool ModelQueuePolicy_TimeoutAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelQueuePolicy_TimeoutAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelQueuePolicy_TimeoutAction>(
    ModelQueuePolicy_TimeoutAction_descriptor(), name, value);
}
enum ModelSequenceBatching_Control_Kind : int {
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_START = 0,
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_READY = 1,
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_END = 2,
  ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_CORRID = 3,
  ModelSequenceBatching_Control_Kind_ModelSequenceBatching_Control_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelSequenceBatching_Control_Kind_ModelSequenceBatching_Control_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelSequenceBatching_Control_Kind_IsValid(int value);
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control_Kind_Kind_MIN = ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_START;
constexpr ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control_Kind_Kind_MAX = ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_CORRID;
constexpr int ModelSequenceBatching_Control_Kind_Kind_ARRAYSIZE = ModelSequenceBatching_Control_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelSequenceBatching_Control_Kind_descriptor();
template<typename T>
inline const std::string& ModelSequenceBatching_Control_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelSequenceBatching_Control_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelSequenceBatching_Control_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelSequenceBatching_Control_Kind_descriptor(), enum_t_value);
}
inline bool ModelSequenceBatching_Control_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelSequenceBatching_Control_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelSequenceBatching_Control_Kind>(
    ModelSequenceBatching_Control_Kind_descriptor(), name, value);
}
enum DataType : int {
  TYPE_INVALID = 0,
  TYPE_BOOL = 1,
  TYPE_UINT8 = 2,
  TYPE_UINT16 = 3,
  TYPE_UINT32 = 4,
  TYPE_UINT64 = 5,
  TYPE_INT8 = 6,
  TYPE_INT16 = 7,
  TYPE_INT32 = 8,
  TYPE_INT64 = 9,
  TYPE_FP16 = 10,
  TYPE_FP32 = 11,
  TYPE_FP64 = 12,
  TYPE_STRING = 13,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = TYPE_INVALID;
constexpr DataType DataType_MAX = TYPE_STRING;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class ModelRateLimiter_Resource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelRateLimiter.Resource) */ {
 public:
  inline ModelRateLimiter_Resource() : ModelRateLimiter_Resource(nullptr) {}
  virtual ~ModelRateLimiter_Resource();

  ModelRateLimiter_Resource(const ModelRateLimiter_Resource& from);
  ModelRateLimiter_Resource(ModelRateLimiter_Resource&& from) noexcept
    : ModelRateLimiter_Resource() {
    *this = ::std::move(from);
  }

  inline ModelRateLimiter_Resource& operator=(const ModelRateLimiter_Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRateLimiter_Resource& operator=(ModelRateLimiter_Resource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelRateLimiter_Resource& default_instance();

  static inline const ModelRateLimiter_Resource* internal_default_instance() {
    return reinterpret_cast<const ModelRateLimiter_Resource*>(
               &_ModelRateLimiter_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModelRateLimiter_Resource& a, ModelRateLimiter_Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRateLimiter_Resource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRateLimiter_Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelRateLimiter_Resource* New() const final {
    return CreateMaybeMessage<ModelRateLimiter_Resource>(nullptr);
  }

  ModelRateLimiter_Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelRateLimiter_Resource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelRateLimiter_Resource& from);
  void MergeFrom(const ModelRateLimiter_Resource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRateLimiter_Resource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelRateLimiter.Resource";
  }
  protected:
  explicit ModelRateLimiter_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kGlobalFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool global = 2;
  void clear_global();
  bool global() const;
  void set_global(bool value);
  private:
  bool _internal_global() const;
  void _internal_set_global(bool value);
  public:

  // uint32 count = 3;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelRateLimiter.Resource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool global_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelRateLimiter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelRateLimiter) */ {
 public:
  inline ModelRateLimiter() : ModelRateLimiter(nullptr) {}
  virtual ~ModelRateLimiter();

  ModelRateLimiter(const ModelRateLimiter& from);
  ModelRateLimiter(ModelRateLimiter&& from) noexcept
    : ModelRateLimiter() {
    *this = ::std::move(from);
  }

  inline ModelRateLimiter& operator=(const ModelRateLimiter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRateLimiter& operator=(ModelRateLimiter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelRateLimiter& default_instance();

  static inline const ModelRateLimiter* internal_default_instance() {
    return reinterpret_cast<const ModelRateLimiter*>(
               &_ModelRateLimiter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModelRateLimiter& a, ModelRateLimiter& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRateLimiter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRateLimiter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelRateLimiter* New() const final {
    return CreateMaybeMessage<ModelRateLimiter>(nullptr);
  }

  ModelRateLimiter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelRateLimiter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelRateLimiter& from);
  void MergeFrom(const ModelRateLimiter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRateLimiter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelRateLimiter";
  }
  protected:
  explicit ModelRateLimiter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelRateLimiter_Resource Resource;

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 1,
    kPriorityFieldNumber = 2,
  };
  // repeated .inference.ModelRateLimiter.Resource resources = 1;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::inference::ModelRateLimiter_Resource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >*
      mutable_resources();
  private:
  const ::inference::ModelRateLimiter_Resource& _internal_resources(int index) const;
  ::inference::ModelRateLimiter_Resource* _internal_add_resources();
  public:
  const ::inference::ModelRateLimiter_Resource& resources(int index) const;
  ::inference::ModelRateLimiter_Resource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >&
      resources() const;

  // uint32 priority = 2;
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::uint32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelRateLimiter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource > resources_;
  ::PROTOBUF_NAMESPACE_ID::uint32 priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelInstanceGroup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInstanceGroup) */ {
 public:
  inline ModelInstanceGroup() : ModelInstanceGroup(nullptr) {}
  virtual ~ModelInstanceGroup();

  ModelInstanceGroup(const ModelInstanceGroup& from);
  ModelInstanceGroup(ModelInstanceGroup&& from) noexcept
    : ModelInstanceGroup() {
    *this = ::std::move(from);
  }

  inline ModelInstanceGroup& operator=(const ModelInstanceGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInstanceGroup& operator=(ModelInstanceGroup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInstanceGroup& default_instance();

  static inline const ModelInstanceGroup* internal_default_instance() {
    return reinterpret_cast<const ModelInstanceGroup*>(
               &_ModelInstanceGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModelInstanceGroup& a, ModelInstanceGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInstanceGroup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInstanceGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInstanceGroup* New() const final {
    return CreateMaybeMessage<ModelInstanceGroup>(nullptr);
  }

  ModelInstanceGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInstanceGroup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInstanceGroup& from);
  void MergeFrom(const ModelInstanceGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInstanceGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInstanceGroup";
  }
  protected:
  explicit ModelInstanceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelInstanceGroup_Kind Kind;
  static constexpr Kind KIND_AUTO =
    ModelInstanceGroup_Kind_KIND_AUTO;
  static constexpr Kind KIND_GPU =
    ModelInstanceGroup_Kind_KIND_GPU;
  static constexpr Kind KIND_CPU =
    ModelInstanceGroup_Kind_KIND_CPU;
  static constexpr Kind KIND_MODEL =
    ModelInstanceGroup_Kind_KIND_MODEL;
  static inline bool Kind_IsValid(int value) {
    return ModelInstanceGroup_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ModelInstanceGroup_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ModelInstanceGroup_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ModelInstanceGroup_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ModelInstanceGroup_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ModelInstanceGroup_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return ModelInstanceGroup_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGpusFieldNumber = 3,
    kProfileFieldNumber = 5,
    kNameFieldNumber = 1,
    kRateLimiterFieldNumber = 6,
    kCountFieldNumber = 2,
    kKindFieldNumber = 4,
  };
  // repeated int32 gpus = 3;
  int gpus_size() const;
  private:
  int _internal_gpus_size() const;
  public:
  void clear_gpus();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gpus(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_gpus() const;
  void _internal_add_gpus(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_gpus();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 gpus(int index) const;
  void set_gpus(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_gpus(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      gpus() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_gpus();

  // repeated string profile = 5;
  int profile_size() const;
  private:
  int _internal_profile_size() const;
  public:
  void clear_profile();
  const std::string& profile(int index) const;
  std::string* mutable_profile(int index);
  void set_profile(int index, const std::string& value);
  void set_profile(int index, std::string&& value);
  void set_profile(int index, const char* value);
  void set_profile(int index, const char* value, size_t size);
  std::string* add_profile();
  void add_profile(const std::string& value);
  void add_profile(std::string&& value);
  void add_profile(const char* value);
  void add_profile(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& profile() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_profile();
  private:
  const std::string& _internal_profile(int index) const;
  std::string* _internal_add_profile();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .inference.ModelRateLimiter rate_limiter = 6;
  bool has_rate_limiter() const;
  private:
  bool _internal_has_rate_limiter() const;
  public:
  void clear_rate_limiter();
  const ::inference::ModelRateLimiter& rate_limiter() const;
  ::inference::ModelRateLimiter* release_rate_limiter();
  ::inference::ModelRateLimiter* mutable_rate_limiter();
  void set_allocated_rate_limiter(::inference::ModelRateLimiter* rate_limiter);
  private:
  const ::inference::ModelRateLimiter& _internal_rate_limiter() const;
  ::inference::ModelRateLimiter* _internal_mutable_rate_limiter();
  public:
  void unsafe_arena_set_allocated_rate_limiter(
      ::inference::ModelRateLimiter* rate_limiter);
  ::inference::ModelRateLimiter* unsafe_arena_release_rate_limiter();

  // int32 count = 2;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .inference.ModelInstanceGroup.Kind kind = 4;
  void clear_kind();
  ::inference::ModelInstanceGroup_Kind kind() const;
  void set_kind(::inference::ModelInstanceGroup_Kind value);
  private:
  ::inference::ModelInstanceGroup_Kind _internal_kind() const;
  void _internal_set_kind(::inference::ModelInstanceGroup_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInstanceGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > gpus_;
  mutable std::atomic<int> _gpus_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> profile_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::inference::ModelRateLimiter* rate_limiter_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelTensorReshape PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelTensorReshape) */ {
 public:
  inline ModelTensorReshape() : ModelTensorReshape(nullptr) {}
  virtual ~ModelTensorReshape();

  ModelTensorReshape(const ModelTensorReshape& from);
  ModelTensorReshape(ModelTensorReshape&& from) noexcept
    : ModelTensorReshape() {
    *this = ::std::move(from);
  }

  inline ModelTensorReshape& operator=(const ModelTensorReshape& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTensorReshape& operator=(ModelTensorReshape&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelTensorReshape& default_instance();

  static inline const ModelTensorReshape* internal_default_instance() {
    return reinterpret_cast<const ModelTensorReshape*>(
               &_ModelTensorReshape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModelTensorReshape& a, ModelTensorReshape& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTensorReshape* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTensorReshape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelTensorReshape* New() const final {
    return CreateMaybeMessage<ModelTensorReshape>(nullptr);
  }

  ModelTensorReshape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelTensorReshape>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelTensorReshape& from);
  void MergeFrom(const ModelTensorReshape& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTensorReshape* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelTensorReshape";
  }
  protected:
  explicit ModelTensorReshape(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
  };
  // repeated int64 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_shape() const;
  void _internal_add_shape(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_shape();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 shape(int index) const;
  void set_shape(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_shape(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:inference.ModelTensorReshape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelInput) */ {
 public:
  inline ModelInput() : ModelInput(nullptr) {}
  virtual ~ModelInput();

  ModelInput(const ModelInput& from);
  ModelInput(ModelInput&& from) noexcept
    : ModelInput() {
    *this = ::std::move(from);
  }

  inline ModelInput& operator=(const ModelInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInput& operator=(ModelInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInput& default_instance();

  static inline const ModelInput* internal_default_instance() {
    return reinterpret_cast<const ModelInput*>(
               &_ModelInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModelInput& a, ModelInput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInput* New() const final {
    return CreateMaybeMessage<ModelInput>(nullptr);
  }

  ModelInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInput& from);
  void MergeFrom(const ModelInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelInput";
  }
  protected:
  explicit ModelInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelInput_Format Format;
  static constexpr Format FORMAT_NONE =
    ModelInput_Format_FORMAT_NONE;
  static constexpr Format FORMAT_NHWC =
    ModelInput_Format_FORMAT_NHWC;
  static constexpr Format FORMAT_NCHW =
    ModelInput_Format_FORMAT_NCHW;
  static inline bool Format_IsValid(int value) {
    return ModelInput_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    ModelInput_Format_Format_MIN;
  static constexpr Format Format_MAX =
    ModelInput_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    ModelInput_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return ModelInput_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return ModelInput_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return ModelInput_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 4,
    kNameFieldNumber = 1,
    kReshapeFieldNumber = 5,
    kDataTypeFieldNumber = 2,
    kFormatFieldNumber = 3,
    kIsShapeTensorFieldNumber = 6,
    kAllowRaggedBatchFieldNumber = 7,
  };
  // repeated int64 dims = 4;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .inference.ModelTensorReshape reshape = 5;
  bool has_reshape() const;
  private:
  bool _internal_has_reshape() const;
  public:
  void clear_reshape();
  const ::inference::ModelTensorReshape& reshape() const;
  ::inference::ModelTensorReshape* release_reshape();
  ::inference::ModelTensorReshape* mutable_reshape();
  void set_allocated_reshape(::inference::ModelTensorReshape* reshape);
  private:
  const ::inference::ModelTensorReshape& _internal_reshape() const;
  ::inference::ModelTensorReshape* _internal_mutable_reshape();
  public:
  void unsafe_arena_set_allocated_reshape(
      ::inference::ModelTensorReshape* reshape);
  ::inference::ModelTensorReshape* unsafe_arena_release_reshape();

  // .inference.DataType data_type = 2;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // .inference.ModelInput.Format format = 3;
  void clear_format();
  ::inference::ModelInput_Format format() const;
  void set_format(::inference::ModelInput_Format value);
  private:
  ::inference::ModelInput_Format _internal_format() const;
  void _internal_set_format(::inference::ModelInput_Format value);
  public:

  // bool is_shape_tensor = 6;
  void clear_is_shape_tensor();
  bool is_shape_tensor() const;
  void set_is_shape_tensor(bool value);
  private:
  bool _internal_is_shape_tensor() const;
  void _internal_set_is_shape_tensor(bool value);
  public:

  // bool allow_ragged_batch = 7;
  void clear_allow_ragged_batch();
  bool allow_ragged_batch() const;
  void set_allow_ragged_batch(bool value);
  private:
  bool _internal_allow_ragged_batch() const;
  void _internal_set_allow_ragged_batch(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  mutable std::atomic<int> _dims_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::inference::ModelTensorReshape* reshape_;
  int data_type_;
  int format_;
  bool is_shape_tensor_;
  bool allow_ragged_batch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOutput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOutput) */ {
 public:
  inline ModelOutput() : ModelOutput(nullptr) {}
  virtual ~ModelOutput();

  ModelOutput(const ModelOutput& from);
  ModelOutput(ModelOutput&& from) noexcept
    : ModelOutput() {
    *this = ::std::move(from);
  }

  inline ModelOutput& operator=(const ModelOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOutput& operator=(ModelOutput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOutput& default_instance();

  static inline const ModelOutput* internal_default_instance() {
    return reinterpret_cast<const ModelOutput*>(
               &_ModelOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModelOutput& a, ModelOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOutput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOutput* New() const final {
    return CreateMaybeMessage<ModelOutput>(nullptr);
  }

  ModelOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOutput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOutput& from);
  void MergeFrom(const ModelOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOutput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOutput";
  }
  protected:
  explicit ModelOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 3,
    kNameFieldNumber = 1,
    kLabelFilenameFieldNumber = 4,
    kReshapeFieldNumber = 5,
    kDataTypeFieldNumber = 2,
    kIsShapeTensorFieldNumber = 6,
  };
  // repeated int64 dims = 3;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string label_filename = 4;
  void clear_label_filename();
  const std::string& label_filename() const;
  void set_label_filename(const std::string& value);
  void set_label_filename(std::string&& value);
  void set_label_filename(const char* value);
  void set_label_filename(const char* value, size_t size);
  std::string* mutable_label_filename();
  std::string* release_label_filename();
  void set_allocated_label_filename(std::string* label_filename);
  private:
  const std::string& _internal_label_filename() const;
  void _internal_set_label_filename(const std::string& value);
  std::string* _internal_mutable_label_filename();
  public:

  // .inference.ModelTensorReshape reshape = 5;
  bool has_reshape() const;
  private:
  bool _internal_has_reshape() const;
  public:
  void clear_reshape();
  const ::inference::ModelTensorReshape& reshape() const;
  ::inference::ModelTensorReshape* release_reshape();
  ::inference::ModelTensorReshape* mutable_reshape();
  void set_allocated_reshape(::inference::ModelTensorReshape* reshape);
  private:
  const ::inference::ModelTensorReshape& _internal_reshape() const;
  ::inference::ModelTensorReshape* _internal_mutable_reshape();
  public:
  void unsafe_arena_set_allocated_reshape(
      ::inference::ModelTensorReshape* reshape);
  ::inference::ModelTensorReshape* unsafe_arena_release_reshape();

  // .inference.DataType data_type = 2;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // bool is_shape_tensor = 6;
  void clear_is_shape_tensor();
  bool is_shape_tensor() const;
  void set_is_shape_tensor(bool value);
  private:
  bool _internal_is_shape_tensor() const;
  void _internal_set_is_shape_tensor(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  mutable std::atomic<int> _dims_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_filename_;
  ::inference::ModelTensorReshape* reshape_;
  int data_type_;
  bool is_shape_tensor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class BatchInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.BatchInput) */ {
 public:
  inline BatchInput() : BatchInput(nullptr) {}
  virtual ~BatchInput();

  BatchInput(const BatchInput& from);
  BatchInput(BatchInput&& from) noexcept
    : BatchInput() {
    *this = ::std::move(from);
  }

  inline BatchInput& operator=(const BatchInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchInput& operator=(BatchInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BatchInput& default_instance();

  static inline const BatchInput* internal_default_instance() {
    return reinterpret_cast<const BatchInput*>(
               &_BatchInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BatchInput& a, BatchInput& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchInput* New() const final {
    return CreateMaybeMessage<BatchInput>(nullptr);
  }

  BatchInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatchInput& from);
  void MergeFrom(const BatchInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.BatchInput";
  }
  protected:
  explicit BatchInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BatchInput_Kind Kind;
  static constexpr Kind BATCH_ELEMENT_COUNT =
    BatchInput_Kind_BATCH_ELEMENT_COUNT;
  static constexpr Kind BATCH_ACCUMULATED_ELEMENT_COUNT =
    BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT;
  static constexpr Kind BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO =
    BatchInput_Kind_BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO;
  static constexpr Kind BATCH_MAX_ELEMENT_COUNT_AS_SHAPE =
    BatchInput_Kind_BATCH_MAX_ELEMENT_COUNT_AS_SHAPE;
  static inline bool Kind_IsValid(int value) {
    return BatchInput_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    BatchInput_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    BatchInput_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    BatchInput_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return BatchInput_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return BatchInput_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return BatchInput_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTargetNameFieldNumber = 2,
    kSourceInputFieldNumber = 4,
    kKindFieldNumber = 1,
    kDataTypeFieldNumber = 3,
  };
  // repeated string target_name = 2;
  int target_name_size() const;
  private:
  int _internal_target_name_size() const;
  public:
  void clear_target_name();
  const std::string& target_name(int index) const;
  std::string* mutable_target_name(int index);
  void set_target_name(int index, const std::string& value);
  void set_target_name(int index, std::string&& value);
  void set_target_name(int index, const char* value);
  void set_target_name(int index, const char* value, size_t size);
  std::string* add_target_name();
  void add_target_name(const std::string& value);
  void add_target_name(std::string&& value);
  void add_target_name(const char* value);
  void add_target_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& target_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_target_name();
  private:
  const std::string& _internal_target_name(int index) const;
  std::string* _internal_add_target_name();
  public:

  // repeated string source_input = 4;
  int source_input_size() const;
  private:
  int _internal_source_input_size() const;
  public:
  void clear_source_input();
  const std::string& source_input(int index) const;
  std::string* mutable_source_input(int index);
  void set_source_input(int index, const std::string& value);
  void set_source_input(int index, std::string&& value);
  void set_source_input(int index, const char* value);
  void set_source_input(int index, const char* value, size_t size);
  std::string* add_source_input();
  void add_source_input(const std::string& value);
  void add_source_input(std::string&& value);
  void add_source_input(const char* value);
  void add_source_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& source_input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_source_input();
  private:
  const std::string& _internal_source_input(int index) const;
  std::string* _internal_add_source_input();
  public:

  // .inference.BatchInput.Kind kind = 1;
  void clear_kind();
  ::inference::BatchInput_Kind kind() const;
  void set_kind(::inference::BatchInput_Kind value);
  private:
  ::inference::BatchInput_Kind _internal_kind() const;
  void _internal_set_kind(::inference::BatchInput_Kind value);
  public:

  // .inference.DataType data_type = 3;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:inference.BatchInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> target_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> source_input_;
  int kind_;
  int data_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class BatchOutput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.BatchOutput) */ {
 public:
  inline BatchOutput() : BatchOutput(nullptr) {}
  virtual ~BatchOutput();

  BatchOutput(const BatchOutput& from);
  BatchOutput(BatchOutput&& from) noexcept
    : BatchOutput() {
    *this = ::std::move(from);
  }

  inline BatchOutput& operator=(const BatchOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchOutput& operator=(BatchOutput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BatchOutput& default_instance();

  static inline const BatchOutput* internal_default_instance() {
    return reinterpret_cast<const BatchOutput*>(
               &_BatchOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BatchOutput& a, BatchOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchOutput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchOutput* New() const final {
    return CreateMaybeMessage<BatchOutput>(nullptr);
  }

  BatchOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchOutput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatchOutput& from);
  void MergeFrom(const BatchOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchOutput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.BatchOutput";
  }
  protected:
  explicit BatchOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BatchOutput_Kind Kind;
  static constexpr Kind BATCH_SCATTER_WITH_INPUT_SHAPE =
    BatchOutput_Kind_BATCH_SCATTER_WITH_INPUT_SHAPE;
  static inline bool Kind_IsValid(int value) {
    return BatchOutput_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    BatchOutput_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    BatchOutput_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    BatchOutput_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return BatchOutput_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return BatchOutput_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return BatchOutput_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTargetNameFieldNumber = 1,
    kSourceInputFieldNumber = 3,
    kKindFieldNumber = 2,
  };
  // repeated string target_name = 1;
  int target_name_size() const;
  private:
  int _internal_target_name_size() const;
  public:
  void clear_target_name();
  const std::string& target_name(int index) const;
  std::string* mutable_target_name(int index);
  void set_target_name(int index, const std::string& value);
  void set_target_name(int index, std::string&& value);
  void set_target_name(int index, const char* value);
  void set_target_name(int index, const char* value, size_t size);
  std::string* add_target_name();
  void add_target_name(const std::string& value);
  void add_target_name(std::string&& value);
  void add_target_name(const char* value);
  void add_target_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& target_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_target_name();
  private:
  const std::string& _internal_target_name(int index) const;
  std::string* _internal_add_target_name();
  public:

  // repeated string source_input = 3;
  int source_input_size() const;
  private:
  int _internal_source_input_size() const;
  public:
  void clear_source_input();
  const std::string& source_input(int index) const;
  std::string* mutable_source_input(int index);
  void set_source_input(int index, const std::string& value);
  void set_source_input(int index, std::string&& value);
  void set_source_input(int index, const char* value);
  void set_source_input(int index, const char* value, size_t size);
  std::string* add_source_input();
  void add_source_input(const std::string& value);
  void add_source_input(std::string&& value);
  void add_source_input(const char* value);
  void add_source_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& source_input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_source_input();
  private:
  const std::string& _internal_source_input(int index) const;
  std::string* _internal_add_source_input();
  public:

  // .inference.BatchOutput.Kind kind = 2;
  void clear_kind();
  ::inference::BatchOutput_Kind kind() const;
  void set_kind(::inference::BatchOutput_Kind value);
  private:
  ::inference::BatchOutput_Kind _internal_kind() const;
  void _internal_set_kind(::inference::BatchOutput_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:inference.BatchOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> target_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> source_input_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy_Latest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy.Latest) */ {
 public:
  inline ModelVersionPolicy_Latest() : ModelVersionPolicy_Latest(nullptr) {}
  virtual ~ModelVersionPolicy_Latest();

  ModelVersionPolicy_Latest(const ModelVersionPolicy_Latest& from);
  ModelVersionPolicy_Latest(ModelVersionPolicy_Latest&& from) noexcept
    : ModelVersionPolicy_Latest() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy_Latest& operator=(const ModelVersionPolicy_Latest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy_Latest& operator=(ModelVersionPolicy_Latest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelVersionPolicy_Latest& default_instance();

  static inline const ModelVersionPolicy_Latest* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy_Latest*>(
               &_ModelVersionPolicy_Latest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ModelVersionPolicy_Latest& a, ModelVersionPolicy_Latest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy_Latest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy_Latest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelVersionPolicy_Latest* New() const final {
    return CreateMaybeMessage<ModelVersionPolicy_Latest>(nullptr);
  }

  ModelVersionPolicy_Latest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelVersionPolicy_Latest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelVersionPolicy_Latest& from);
  void MergeFrom(const ModelVersionPolicy_Latest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionPolicy_Latest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy.Latest";
  }
  protected:
  explicit ModelVersionPolicy_Latest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumVersionsFieldNumber = 1,
  };
  // uint32 num_versions = 1;
  void clear_num_versions();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_versions() const;
  void set_num_versions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_versions() const;
  void _internal_set_num_versions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy.Latest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_versions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy_All PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy.All) */ {
 public:
  inline ModelVersionPolicy_All() : ModelVersionPolicy_All(nullptr) {}
  virtual ~ModelVersionPolicy_All();

  ModelVersionPolicy_All(const ModelVersionPolicy_All& from);
  ModelVersionPolicy_All(ModelVersionPolicy_All&& from) noexcept
    : ModelVersionPolicy_All() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy_All& operator=(const ModelVersionPolicy_All& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy_All& operator=(ModelVersionPolicy_All&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelVersionPolicy_All& default_instance();

  static inline const ModelVersionPolicy_All* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy_All*>(
               &_ModelVersionPolicy_All_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModelVersionPolicy_All& a, ModelVersionPolicy_All& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy_All* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy_All* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelVersionPolicy_All* New() const final {
    return CreateMaybeMessage<ModelVersionPolicy_All>(nullptr);
  }

  ModelVersionPolicy_All* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelVersionPolicy_All>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelVersionPolicy_All& from);
  void MergeFrom(const ModelVersionPolicy_All& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionPolicy_All* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy.All";
  }
  protected:
  explicit ModelVersionPolicy_All(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy.All)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy_Specific PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy.Specific) */ {
 public:
  inline ModelVersionPolicy_Specific() : ModelVersionPolicy_Specific(nullptr) {}
  virtual ~ModelVersionPolicy_Specific();

  ModelVersionPolicy_Specific(const ModelVersionPolicy_Specific& from);
  ModelVersionPolicy_Specific(ModelVersionPolicy_Specific&& from) noexcept
    : ModelVersionPolicy_Specific() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy_Specific& operator=(const ModelVersionPolicy_Specific& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy_Specific& operator=(ModelVersionPolicy_Specific&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelVersionPolicy_Specific& default_instance();

  static inline const ModelVersionPolicy_Specific* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy_Specific*>(
               &_ModelVersionPolicy_Specific_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModelVersionPolicy_Specific& a, ModelVersionPolicy_Specific& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy_Specific* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy_Specific* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelVersionPolicy_Specific* New() const final {
    return CreateMaybeMessage<ModelVersionPolicy_Specific>(nullptr);
  }

  ModelVersionPolicy_Specific* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelVersionPolicy_Specific>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelVersionPolicy_Specific& from);
  void MergeFrom(const ModelVersionPolicy_Specific& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionPolicy_Specific* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy.Specific";
  }
  protected:
  explicit ModelVersionPolicy_Specific(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 1,
  };
  // repeated int64 versions = 1;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_versions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_versions() const;
  void _internal_add_versions(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_versions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 versions(int index) const;
  void set_versions(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_versions(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_versions();

  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy.Specific)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > versions_;
  mutable std::atomic<int> _versions_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelVersionPolicy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelVersionPolicy) */ {
 public:
  inline ModelVersionPolicy() : ModelVersionPolicy(nullptr) {}
  virtual ~ModelVersionPolicy();

  ModelVersionPolicy(const ModelVersionPolicy& from);
  ModelVersionPolicy(ModelVersionPolicy&& from) noexcept
    : ModelVersionPolicy() {
    *this = ::std::move(from);
  }

  inline ModelVersionPolicy& operator=(const ModelVersionPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelVersionPolicy& operator=(ModelVersionPolicy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelVersionPolicy& default_instance();

  enum PolicyChoiceCase {
    kLatest = 1,
    kAll = 2,
    kSpecific = 3,
    POLICY_CHOICE_NOT_SET = 0,
  };

  static inline const ModelVersionPolicy* internal_default_instance() {
    return reinterpret_cast<const ModelVersionPolicy*>(
               &_ModelVersionPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ModelVersionPolicy& a, ModelVersionPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelVersionPolicy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelVersionPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelVersionPolicy* New() const final {
    return CreateMaybeMessage<ModelVersionPolicy>(nullptr);
  }

  ModelVersionPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelVersionPolicy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelVersionPolicy& from);
  void MergeFrom(const ModelVersionPolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelVersionPolicy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelVersionPolicy";
  }
  protected:
  explicit ModelVersionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelVersionPolicy_Latest Latest;
  typedef ModelVersionPolicy_All All;
  typedef ModelVersionPolicy_Specific Specific;

  // accessors -------------------------------------------------------

  enum : int {
    kLatestFieldNumber = 1,
    kAllFieldNumber = 2,
    kSpecificFieldNumber = 3,
  };
  // .inference.ModelVersionPolicy.Latest latest = 1;
  bool has_latest() const;
  private:
  bool _internal_has_latest() const;
  public:
  void clear_latest();
  const ::inference::ModelVersionPolicy_Latest& latest() const;
  ::inference::ModelVersionPolicy_Latest* release_latest();
  ::inference::ModelVersionPolicy_Latest* mutable_latest();
  void set_allocated_latest(::inference::ModelVersionPolicy_Latest* latest);
  private:
  const ::inference::ModelVersionPolicy_Latest& _internal_latest() const;
  ::inference::ModelVersionPolicy_Latest* _internal_mutable_latest();
  public:
  void unsafe_arena_set_allocated_latest(
      ::inference::ModelVersionPolicy_Latest* latest);
  ::inference::ModelVersionPolicy_Latest* unsafe_arena_release_latest();

  // .inference.ModelVersionPolicy.All all = 2;
  bool has_all() const;
  private:
  bool _internal_has_all() const;
  public:
  void clear_all();
  const ::inference::ModelVersionPolicy_All& all() const;
  ::inference::ModelVersionPolicy_All* release_all();
  ::inference::ModelVersionPolicy_All* mutable_all();
  void set_allocated_all(::inference::ModelVersionPolicy_All* all);
  private:
  const ::inference::ModelVersionPolicy_All& _internal_all() const;
  ::inference::ModelVersionPolicy_All* _internal_mutable_all();
  public:
  void unsafe_arena_set_allocated_all(
      ::inference::ModelVersionPolicy_All* all);
  ::inference::ModelVersionPolicy_All* unsafe_arena_release_all();

  // .inference.ModelVersionPolicy.Specific specific = 3;
  bool has_specific() const;
  private:
  bool _internal_has_specific() const;
  public:
  void clear_specific();
  const ::inference::ModelVersionPolicy_Specific& specific() const;
  ::inference::ModelVersionPolicy_Specific* release_specific();
  ::inference::ModelVersionPolicy_Specific* mutable_specific();
  void set_allocated_specific(::inference::ModelVersionPolicy_Specific* specific);
  private:
  const ::inference::ModelVersionPolicy_Specific& _internal_specific() const;
  ::inference::ModelVersionPolicy_Specific* _internal_mutable_specific();
  public:
  void unsafe_arena_set_allocated_specific(
      ::inference::ModelVersionPolicy_Specific* specific);
  ::inference::ModelVersionPolicy_Specific* unsafe_arena_release_specific();

  void clear_policy_choice();
  PolicyChoiceCase policy_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelVersionPolicy)
 private:
  class _Internal;
  void set_has_latest();
  void set_has_all();
  void set_has_specific();

  inline bool has_policy_choice() const;
  inline void clear_has_policy_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PolicyChoiceUnion {
    PolicyChoiceUnion() {}
    ::inference::ModelVersionPolicy_Latest* latest_;
    ::inference::ModelVersionPolicy_All* all_;
    ::inference::ModelVersionPolicy_Specific* specific_;
  } policy_choice_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Graph PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Graph) */ {
 public:
  inline ModelOptimizationPolicy_Graph() : ModelOptimizationPolicy_Graph(nullptr) {}
  virtual ~ModelOptimizationPolicy_Graph();

  ModelOptimizationPolicy_Graph(const ModelOptimizationPolicy_Graph& from);
  ModelOptimizationPolicy_Graph(ModelOptimizationPolicy_Graph&& from) noexcept
    : ModelOptimizationPolicy_Graph() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Graph& operator=(const ModelOptimizationPolicy_Graph& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Graph& operator=(ModelOptimizationPolicy_Graph&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_Graph& default_instance();

  static inline const ModelOptimizationPolicy_Graph* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Graph*>(
               &_ModelOptimizationPolicy_Graph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ModelOptimizationPolicy_Graph& a, ModelOptimizationPolicy_Graph& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Graph* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Graph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_Graph* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Graph>(nullptr);
  }

  ModelOptimizationPolicy_Graph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Graph>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_Graph& from);
  void MergeFrom(const ModelOptimizationPolicy_Graph& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Graph* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Graph";
  }
  protected:
  explicit ModelOptimizationPolicy_Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // int32 level = 1;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_level() const;
  void _internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Graph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_Shape PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape) */ {
 public:
  inline ModelOptimizationPolicy_Cuda_GraphSpec_Shape() : ModelOptimizationPolicy_Cuda_GraphSpec_Shape(nullptr) {}
  virtual ~ModelOptimizationPolicy_Cuda_GraphSpec_Shape();

  ModelOptimizationPolicy_Cuda_GraphSpec_Shape(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from);
  ModelOptimizationPolicy_Cuda_GraphSpec_Shape(ModelOptimizationPolicy_Cuda_GraphSpec_Shape&& from) noexcept
    : ModelOptimizationPolicy_Cuda_GraphSpec_Shape() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda_GraphSpec_Shape& operator=(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda_GraphSpec_Shape& operator=(ModelOptimizationPolicy_Cuda_GraphSpec_Shape&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& default_instance();

  static inline const ModelOptimizationPolicy_Cuda_GraphSpec_Shape* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_Shape*>(
               &_ModelOptimizationPolicy_Cuda_GraphSpec_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape& a, ModelOptimizationPolicy_Cuda_GraphSpec_Shape& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_Cuda_GraphSpec_Shape* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec_Shape>(nullptr);
  }

  ModelOptimizationPolicy_Cuda_GraphSpec_Shape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec_Shape>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from);
  void MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_Shape& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_Shape* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 1,
  };
  // repeated int64 dim = 1;
  int dim_size() const;
  private:
  int _internal_dim_size() const;
  public:
  void clear_dim();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dim(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dim() const;
  void _internal_add_dim(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dim();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dim(int index) const;
  void set_dim(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dim(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dim() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dim();

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dim_;
  mutable std::atomic<int> _dim_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse();
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse& other);
  static const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse*>(&_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.InputEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[14];
  }

  public:
};

// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound) */ {
 public:
  inline ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound() : ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(nullptr) {}
  virtual ~ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound();

  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from);
  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&& from) noexcept
    : ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& operator=(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& operator=(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& default_instance();

  static inline const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound*>(
               &_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& a, ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound>(nullptr);
  }

  ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from);
  void MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 2,
    kBatchSizeFieldNumber = 1,
  };
  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      _internal_input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      _internal_mutable_input();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      mutable_input();

  // int32 batch_size = 1;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_InputEntry_DoNotUse,
      std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> input_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse, 
    std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse();
  explicit ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse& other);
  static const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse*>(&_ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.Cuda.GraphSpec.InputEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[16];
  }

  public:
};

// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda_GraphSpec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda.GraphSpec) */ {
 public:
  inline ModelOptimizationPolicy_Cuda_GraphSpec() : ModelOptimizationPolicy_Cuda_GraphSpec(nullptr) {}
  virtual ~ModelOptimizationPolicy_Cuda_GraphSpec();

  ModelOptimizationPolicy_Cuda_GraphSpec(const ModelOptimizationPolicy_Cuda_GraphSpec& from);
  ModelOptimizationPolicy_Cuda_GraphSpec(ModelOptimizationPolicy_Cuda_GraphSpec&& from) noexcept
    : ModelOptimizationPolicy_Cuda_GraphSpec() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda_GraphSpec& operator=(const ModelOptimizationPolicy_Cuda_GraphSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda_GraphSpec& operator=(ModelOptimizationPolicy_Cuda_GraphSpec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_Cuda_GraphSpec& default_instance();

  static inline const ModelOptimizationPolicy_Cuda_GraphSpec* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda_GraphSpec*>(
               &_ModelOptimizationPolicy_Cuda_GraphSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ModelOptimizationPolicy_Cuda_GraphSpec& a, ModelOptimizationPolicy_Cuda_GraphSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda_GraphSpec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda_GraphSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_Cuda_GraphSpec* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec>(nullptr);
  }

  ModelOptimizationPolicy_Cuda_GraphSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda_GraphSpec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_Cuda_GraphSpec& from);
  void MergeFrom(const ModelOptimizationPolicy_Cuda_GraphSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda_GraphSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda.GraphSpec";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda_GraphSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_Cuda_GraphSpec_Shape Shape;
  typedef ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound LowerBound;

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 2,
    kGraphLowerBoundFieldNumber = 3,
    kBatchSizeFieldNumber = 1,
  };
  // map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      _internal_input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      _internal_mutable_input();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
      input() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
      mutable_input();

  // .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
  bool has_graph_lower_bound() const;
  private:
  bool _internal_has_graph_lower_bound() const;
  public:
  void clear_graph_lower_bound();
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& graph_lower_bound() const;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* release_graph_lower_bound();
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* mutable_graph_lower_bound();
  void set_allocated_graph_lower_bound(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound);
  private:
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& _internal_graph_lower_bound() const;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* _internal_mutable_graph_lower_bound();
  public:
  void unsafe_arena_set_allocated_graph_lower_bound(
      ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound);
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* unsafe_arena_release_graph_lower_bound();

  // int32 batch_size = 1;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda.GraphSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelOptimizationPolicy_Cuda_GraphSpec_InputEntry_DoNotUse,
      std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> input_;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_Cuda PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.Cuda) */ {
 public:
  inline ModelOptimizationPolicy_Cuda() : ModelOptimizationPolicy_Cuda(nullptr) {}
  virtual ~ModelOptimizationPolicy_Cuda();

  ModelOptimizationPolicy_Cuda(const ModelOptimizationPolicy_Cuda& from);
  ModelOptimizationPolicy_Cuda(ModelOptimizationPolicy_Cuda&& from) noexcept
    : ModelOptimizationPolicy_Cuda() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_Cuda& operator=(const ModelOptimizationPolicy_Cuda& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_Cuda& operator=(ModelOptimizationPolicy_Cuda&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_Cuda& default_instance();

  static inline const ModelOptimizationPolicy_Cuda* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_Cuda*>(
               &_ModelOptimizationPolicy_Cuda_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ModelOptimizationPolicy_Cuda& a, ModelOptimizationPolicy_Cuda& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_Cuda* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_Cuda* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_Cuda* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda>(nullptr);
  }

  ModelOptimizationPolicy_Cuda* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_Cuda>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_Cuda& from);
  void MergeFrom(const ModelOptimizationPolicy_Cuda& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_Cuda* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.Cuda";
  }
  protected:
  explicit ModelOptimizationPolicy_Cuda(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_Cuda_GraphSpec GraphSpec;

  // accessors -------------------------------------------------------

  enum : int {
    kGraphSpecFieldNumber = 3,
    kGraphsFieldNumber = 1,
    kBusyWaitEventsFieldNumber = 2,
  };
  // repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
  int graph_spec_size() const;
  private:
  int _internal_graph_spec_size() const;
  public:
  void clear_graph_spec();
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* mutable_graph_spec(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >*
      mutable_graph_spec();
  private:
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& _internal_graph_spec(int index) const;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* _internal_add_graph_spec();
  public:
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& graph_spec(int index) const;
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* add_graph_spec();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >&
      graph_spec() const;

  // bool graphs = 1;
  void clear_graphs();
  bool graphs() const;
  void set_graphs(bool value);
  private:
  bool _internal_graphs() const;
  void _internal_set_graphs(bool value);
  public:

  // bool busy_wait_events = 2;
  void clear_busy_wait_events();
  bool busy_wait_events() const;
  void set_busy_wait_events(bool value);
  private:
  bool _internal_busy_wait_events() const;
  void _internal_set_busy_wait_events(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.Cuda)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec > graph_spec_;
  bool graphs_;
  bool busy_wait_events_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse();
  explicit ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse& other);
  static const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse*>(&_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.ParametersEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[19];
  }

  public:
};

// -------------------------------------------------------------------

class ModelOptimizationPolicy_ExecutionAccelerators_Accelerator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator) */ {
 public:
  inline ModelOptimizationPolicy_ExecutionAccelerators_Accelerator() : ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(nullptr) {}
  virtual ~ModelOptimizationPolicy_ExecutionAccelerators_Accelerator();

  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from);
  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator&& from) noexcept
    : ModelOptimizationPolicy_ExecutionAccelerators_Accelerator() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& operator=(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& operator=(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& default_instance();

  static inline const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator*>(
               &_ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& a, ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator>(nullptr);
  }

  ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_ExecutionAccelerators_Accelerator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from);
  void MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator";
  }
  protected:
  explicit ModelOptimizationPolicy_ExecutionAccelerators_Accelerator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelOptimizationPolicy_ExecutionAccelerators_Accelerator_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_ExecutionAccelerators PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.ExecutionAccelerators) */ {
 public:
  inline ModelOptimizationPolicy_ExecutionAccelerators() : ModelOptimizationPolicy_ExecutionAccelerators(nullptr) {}
  virtual ~ModelOptimizationPolicy_ExecutionAccelerators();

  ModelOptimizationPolicy_ExecutionAccelerators(const ModelOptimizationPolicy_ExecutionAccelerators& from);
  ModelOptimizationPolicy_ExecutionAccelerators(ModelOptimizationPolicy_ExecutionAccelerators&& from) noexcept
    : ModelOptimizationPolicy_ExecutionAccelerators() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_ExecutionAccelerators& operator=(const ModelOptimizationPolicy_ExecutionAccelerators& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_ExecutionAccelerators& operator=(ModelOptimizationPolicy_ExecutionAccelerators&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_ExecutionAccelerators& default_instance();

  static inline const ModelOptimizationPolicy_ExecutionAccelerators* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_ExecutionAccelerators*>(
               &_ModelOptimizationPolicy_ExecutionAccelerators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ModelOptimizationPolicy_ExecutionAccelerators& a, ModelOptimizationPolicy_ExecutionAccelerators& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_ExecutionAccelerators* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_ExecutionAccelerators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_ExecutionAccelerators* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_ExecutionAccelerators>(nullptr);
  }

  ModelOptimizationPolicy_ExecutionAccelerators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_ExecutionAccelerators>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_ExecutionAccelerators& from);
  void MergeFrom(const ModelOptimizationPolicy_ExecutionAccelerators& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_ExecutionAccelerators* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.ExecutionAccelerators";
  }
  protected:
  explicit ModelOptimizationPolicy_ExecutionAccelerators(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_ExecutionAccelerators_Accelerator Accelerator;

  // accessors -------------------------------------------------------

  enum : int {
    kGpuExecutionAcceleratorFieldNumber = 1,
    kCpuExecutionAcceleratorFieldNumber = 2,
  };
  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
  int gpu_execution_accelerator_size() const;
  private:
  int _internal_gpu_execution_accelerator_size() const;
  public:
  void clear_gpu_execution_accelerator();
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* mutable_gpu_execution_accelerator(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
      mutable_gpu_execution_accelerator();
  private:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& _internal_gpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _internal_add_gpu_execution_accelerator();
  public:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& gpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* add_gpu_execution_accelerator();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
      gpu_execution_accelerator() const;

  // repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
  int cpu_execution_accelerator_size() const;
  private:
  int _internal_cpu_execution_accelerator_size() const;
  public:
  void clear_cpu_execution_accelerator();
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* mutable_cpu_execution_accelerator(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
      mutable_cpu_execution_accelerator();
  private:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& _internal_cpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* _internal_add_cpu_execution_accelerator();
  public:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& cpu_execution_accelerator(int index) const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* add_cpu_execution_accelerator();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
      cpu_execution_accelerator() const;

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.ExecutionAccelerators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator > gpu_execution_accelerator_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator > cpu_execution_accelerator_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy_PinnedMemoryBuffer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy.PinnedMemoryBuffer) */ {
 public:
  inline ModelOptimizationPolicy_PinnedMemoryBuffer() : ModelOptimizationPolicy_PinnedMemoryBuffer(nullptr) {}
  virtual ~ModelOptimizationPolicy_PinnedMemoryBuffer();

  ModelOptimizationPolicy_PinnedMemoryBuffer(const ModelOptimizationPolicy_PinnedMemoryBuffer& from);
  ModelOptimizationPolicy_PinnedMemoryBuffer(ModelOptimizationPolicy_PinnedMemoryBuffer&& from) noexcept
    : ModelOptimizationPolicy_PinnedMemoryBuffer() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy_PinnedMemoryBuffer& operator=(const ModelOptimizationPolicy_PinnedMemoryBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy_PinnedMemoryBuffer& operator=(ModelOptimizationPolicy_PinnedMemoryBuffer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy_PinnedMemoryBuffer& default_instance();

  static inline const ModelOptimizationPolicy_PinnedMemoryBuffer* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy_PinnedMemoryBuffer*>(
               &_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ModelOptimizationPolicy_PinnedMemoryBuffer& a, ModelOptimizationPolicy_PinnedMemoryBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy_PinnedMemoryBuffer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy_PinnedMemoryBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy_PinnedMemoryBuffer* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_PinnedMemoryBuffer>(nullptr);
  }

  ModelOptimizationPolicy_PinnedMemoryBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy_PinnedMemoryBuffer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy_PinnedMemoryBuffer& from);
  void MergeFrom(const ModelOptimizationPolicy_PinnedMemoryBuffer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy_PinnedMemoryBuffer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy.PinnedMemoryBuffer";
  }
  protected:
  explicit ModelOptimizationPolicy_PinnedMemoryBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy.PinnedMemoryBuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOptimizationPolicy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOptimizationPolicy) */ {
 public:
  inline ModelOptimizationPolicy() : ModelOptimizationPolicy(nullptr) {}
  virtual ~ModelOptimizationPolicy();

  ModelOptimizationPolicy(const ModelOptimizationPolicy& from);
  ModelOptimizationPolicy(ModelOptimizationPolicy&& from) noexcept
    : ModelOptimizationPolicy() {
    *this = ::std::move(from);
  }

  inline ModelOptimizationPolicy& operator=(const ModelOptimizationPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOptimizationPolicy& operator=(ModelOptimizationPolicy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOptimizationPolicy& default_instance();

  static inline const ModelOptimizationPolicy* internal_default_instance() {
    return reinterpret_cast<const ModelOptimizationPolicy*>(
               &_ModelOptimizationPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ModelOptimizationPolicy& a, ModelOptimizationPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOptimizationPolicy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOptimizationPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOptimizationPolicy* New() const final {
    return CreateMaybeMessage<ModelOptimizationPolicy>(nullptr);
  }

  ModelOptimizationPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOptimizationPolicy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOptimizationPolicy& from);
  void MergeFrom(const ModelOptimizationPolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOptimizationPolicy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOptimizationPolicy";
  }
  protected:
  explicit ModelOptimizationPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelOptimizationPolicy_Graph Graph;
  typedef ModelOptimizationPolicy_Cuda Cuda;
  typedef ModelOptimizationPolicy_ExecutionAccelerators ExecutionAccelerators;
  typedef ModelOptimizationPolicy_PinnedMemoryBuffer PinnedMemoryBuffer;

  typedef ModelOptimizationPolicy_ModelPriority ModelPriority;
  static constexpr ModelPriority PRIORITY_DEFAULT =
    ModelOptimizationPolicy_ModelPriority_PRIORITY_DEFAULT;
  static constexpr ModelPriority PRIORITY_MAX =
    ModelOptimizationPolicy_ModelPriority_PRIORITY_MAX;
  static constexpr ModelPriority PRIORITY_MIN =
    ModelOptimizationPolicy_ModelPriority_PRIORITY_MIN;
  static inline bool ModelPriority_IsValid(int value) {
    return ModelOptimizationPolicy_ModelPriority_IsValid(value);
  }
  static constexpr ModelPriority ModelPriority_MIN =
    ModelOptimizationPolicy_ModelPriority_ModelPriority_MIN;
  static constexpr ModelPriority ModelPriority_MAX =
    ModelOptimizationPolicy_ModelPriority_ModelPriority_MAX;
  static constexpr int ModelPriority_ARRAYSIZE =
    ModelOptimizationPolicy_ModelPriority_ModelPriority_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModelPriority_descriptor() {
    return ModelOptimizationPolicy_ModelPriority_descriptor();
  }
  template<typename T>
  static inline const std::string& ModelPriority_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModelPriority>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModelPriority_Name.");
    return ModelOptimizationPolicy_ModelPriority_Name(enum_t_value);
  }
  static inline bool ModelPriority_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModelPriority* value) {
    return ModelOptimizationPolicy_ModelPriority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGraphFieldNumber = 1,
    kCudaFieldNumber = 3,
    kExecutionAcceleratorsFieldNumber = 4,
    kInputPinnedMemoryFieldNumber = 5,
    kOutputPinnedMemoryFieldNumber = 6,
    kPriorityFieldNumber = 2,
  };
  // .inference.ModelOptimizationPolicy.Graph graph = 1;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::inference::ModelOptimizationPolicy_Graph& graph() const;
  ::inference::ModelOptimizationPolicy_Graph* release_graph();
  ::inference::ModelOptimizationPolicy_Graph* mutable_graph();
  void set_allocated_graph(::inference::ModelOptimizationPolicy_Graph* graph);
  private:
  const ::inference::ModelOptimizationPolicy_Graph& _internal_graph() const;
  ::inference::ModelOptimizationPolicy_Graph* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::inference::ModelOptimizationPolicy_Graph* graph);
  ::inference::ModelOptimizationPolicy_Graph* unsafe_arena_release_graph();

  // .inference.ModelOptimizationPolicy.Cuda cuda = 3;
  bool has_cuda() const;
  private:
  bool _internal_has_cuda() const;
  public:
  void clear_cuda();
  const ::inference::ModelOptimizationPolicy_Cuda& cuda() const;
  ::inference::ModelOptimizationPolicy_Cuda* release_cuda();
  ::inference::ModelOptimizationPolicy_Cuda* mutable_cuda();
  void set_allocated_cuda(::inference::ModelOptimizationPolicy_Cuda* cuda);
  private:
  const ::inference::ModelOptimizationPolicy_Cuda& _internal_cuda() const;
  ::inference::ModelOptimizationPolicy_Cuda* _internal_mutable_cuda();
  public:
  void unsafe_arena_set_allocated_cuda(
      ::inference::ModelOptimizationPolicy_Cuda* cuda);
  ::inference::ModelOptimizationPolicy_Cuda* unsafe_arena_release_cuda();

  // .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
  bool has_execution_accelerators() const;
  private:
  bool _internal_has_execution_accelerators() const;
  public:
  void clear_execution_accelerators();
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& execution_accelerators() const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* release_execution_accelerators();
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* mutable_execution_accelerators();
  void set_allocated_execution_accelerators(::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators);
  private:
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& _internal_execution_accelerators() const;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* _internal_mutable_execution_accelerators();
  public:
  void unsafe_arena_set_allocated_execution_accelerators(
      ::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators);
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* unsafe_arena_release_execution_accelerators();

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
  bool has_input_pinned_memory() const;
  private:
  bool _internal_has_input_pinned_memory() const;
  public:
  void clear_input_pinned_memory();
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& input_pinned_memory() const;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* release_input_pinned_memory();
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* mutable_input_pinned_memory();
  void set_allocated_input_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory);
  private:
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& _internal_input_pinned_memory() const;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* _internal_mutable_input_pinned_memory();
  public:
  void unsafe_arena_set_allocated_input_pinned_memory(
      ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory);
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* unsafe_arena_release_input_pinned_memory();

  // .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
  bool has_output_pinned_memory() const;
  private:
  bool _internal_has_output_pinned_memory() const;
  public:
  void clear_output_pinned_memory();
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& output_pinned_memory() const;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* release_output_pinned_memory();
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* mutable_output_pinned_memory();
  void set_allocated_output_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory);
  private:
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& _internal_output_pinned_memory() const;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* _internal_mutable_output_pinned_memory();
  public:
  void unsafe_arena_set_allocated_output_pinned_memory(
      ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory);
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* unsafe_arena_release_output_pinned_memory();

  // .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
  void clear_priority();
  ::inference::ModelOptimizationPolicy_ModelPriority priority() const;
  void set_priority(::inference::ModelOptimizationPolicy_ModelPriority value);
  private:
  ::inference::ModelOptimizationPolicy_ModelPriority _internal_priority() const;
  void _internal_set_priority(::inference::ModelOptimizationPolicy_ModelPriority value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOptimizationPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::inference::ModelOptimizationPolicy_Graph* graph_;
  ::inference::ModelOptimizationPolicy_Cuda* cuda_;
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators_;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory_;
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory_;
  int priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelQueuePolicy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelQueuePolicy) */ {
 public:
  inline ModelQueuePolicy() : ModelQueuePolicy(nullptr) {}
  virtual ~ModelQueuePolicy();

  ModelQueuePolicy(const ModelQueuePolicy& from);
  ModelQueuePolicy(ModelQueuePolicy&& from) noexcept
    : ModelQueuePolicy() {
    *this = ::std::move(from);
  }

  inline ModelQueuePolicy& operator=(const ModelQueuePolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelQueuePolicy& operator=(ModelQueuePolicy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelQueuePolicy& default_instance();

  static inline const ModelQueuePolicy* internal_default_instance() {
    return reinterpret_cast<const ModelQueuePolicy*>(
               &_ModelQueuePolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ModelQueuePolicy& a, ModelQueuePolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelQueuePolicy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelQueuePolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelQueuePolicy* New() const final {
    return CreateMaybeMessage<ModelQueuePolicy>(nullptr);
  }

  ModelQueuePolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelQueuePolicy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelQueuePolicy& from);
  void MergeFrom(const ModelQueuePolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelQueuePolicy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelQueuePolicy";
  }
  protected:
  explicit ModelQueuePolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelQueuePolicy_TimeoutAction TimeoutAction;
  static constexpr TimeoutAction REJECT =
    ModelQueuePolicy_TimeoutAction_REJECT;
  static constexpr TimeoutAction DELAY =
    ModelQueuePolicy_TimeoutAction_DELAY;
  static inline bool TimeoutAction_IsValid(int value) {
    return ModelQueuePolicy_TimeoutAction_IsValid(value);
  }
  static constexpr TimeoutAction TimeoutAction_MIN =
    ModelQueuePolicy_TimeoutAction_TimeoutAction_MIN;
  static constexpr TimeoutAction TimeoutAction_MAX =
    ModelQueuePolicy_TimeoutAction_TimeoutAction_MAX;
  static constexpr int TimeoutAction_ARRAYSIZE =
    ModelQueuePolicy_TimeoutAction_TimeoutAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TimeoutAction_descriptor() {
    return ModelQueuePolicy_TimeoutAction_descriptor();
  }
  template<typename T>
  static inline const std::string& TimeoutAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TimeoutAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TimeoutAction_Name.");
    return ModelQueuePolicy_TimeoutAction_Name(enum_t_value);
  }
  static inline bool TimeoutAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TimeoutAction* value) {
    return ModelQueuePolicy_TimeoutAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultTimeoutMicrosecondsFieldNumber = 2,
    kTimeoutActionFieldNumber = 1,
    kAllowTimeoutOverrideFieldNumber = 3,
    kMaxQueueSizeFieldNumber = 4,
  };
  // uint64 default_timeout_microseconds = 2;
  void clear_default_timeout_microseconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 default_timeout_microseconds() const;
  void set_default_timeout_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_default_timeout_microseconds() const;
  void _internal_set_default_timeout_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
  void clear_timeout_action();
  ::inference::ModelQueuePolicy_TimeoutAction timeout_action() const;
  void set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value);
  private:
  ::inference::ModelQueuePolicy_TimeoutAction _internal_timeout_action() const;
  void _internal_set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value);
  public:

  // bool allow_timeout_override = 3;
  void clear_allow_timeout_override();
  bool allow_timeout_override() const;
  void set_allow_timeout_override(bool value);
  private:
  bool _internal_allow_timeout_override() const;
  void _internal_set_allow_timeout_override(bool value);
  public:

  // uint32 max_queue_size = 4;
  void clear_max_queue_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_queue_size() const;
  void set_max_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_queue_size() const;
  void _internal_set_max_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelQueuePolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 default_timeout_microseconds_;
  int timeout_action_;
  bool allow_timeout_override_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_queue_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse();
  explicit ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse& other);
  static const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse*>(&_ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[25];
  }

  public:
};

// -------------------------------------------------------------------

class ModelDynamicBatching PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelDynamicBatching) */ {
 public:
  inline ModelDynamicBatching() : ModelDynamicBatching(nullptr) {}
  virtual ~ModelDynamicBatching();

  ModelDynamicBatching(const ModelDynamicBatching& from);
  ModelDynamicBatching(ModelDynamicBatching&& from) noexcept
    : ModelDynamicBatching() {
    *this = ::std::move(from);
  }

  inline ModelDynamicBatching& operator=(const ModelDynamicBatching& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelDynamicBatching& operator=(ModelDynamicBatching&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelDynamicBatching& default_instance();

  static inline const ModelDynamicBatching* internal_default_instance() {
    return reinterpret_cast<const ModelDynamicBatching*>(
               &_ModelDynamicBatching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ModelDynamicBatching& a, ModelDynamicBatching& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelDynamicBatching* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelDynamicBatching* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelDynamicBatching* New() const final {
    return CreateMaybeMessage<ModelDynamicBatching>(nullptr);
  }

  ModelDynamicBatching* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelDynamicBatching>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelDynamicBatching& from);
  void MergeFrom(const ModelDynamicBatching& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelDynamicBatching* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelDynamicBatching";
  }
  protected:
  explicit ModelDynamicBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPreferredBatchSizeFieldNumber = 1,
    kPriorityQueuePolicyFieldNumber = 7,
    kDefaultQueuePolicyFieldNumber = 6,
    kMaxQueueDelayMicrosecondsFieldNumber = 2,
    kPreserveOrderingFieldNumber = 3,
    kPriorityLevelsFieldNumber = 4,
    kDefaultPriorityLevelFieldNumber = 5,
  };
  // repeated int32 preferred_batch_size = 1;
  int preferred_batch_size_size() const;
  private:
  int _internal_preferred_batch_size_size() const;
  public:
  void clear_preferred_batch_size();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_preferred_batch_size(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_preferred_batch_size() const;
  void _internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_preferred_batch_size();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 preferred_batch_size(int index) const;
  void set_preferred_batch_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      preferred_batch_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_preferred_batch_size();

  // map<uint32, .inference.ModelQueuePolicy> priority_queue_policy = 7;
  int priority_queue_policy_size() const;
  private:
  int _internal_priority_queue_policy_size() const;
  public:
  void clear_priority_queue_policy();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >&
      _internal_priority_queue_policy() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >*
      _internal_mutable_priority_queue_policy();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >&
      priority_queue_policy() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >*
      mutable_priority_queue_policy();

  // .inference.ModelQueuePolicy default_queue_policy = 6;
  bool has_default_queue_policy() const;
  private:
  bool _internal_has_default_queue_policy() const;
  public:
  void clear_default_queue_policy();
  const ::inference::ModelQueuePolicy& default_queue_policy() const;
  ::inference::ModelQueuePolicy* release_default_queue_policy();
  ::inference::ModelQueuePolicy* mutable_default_queue_policy();
  void set_allocated_default_queue_policy(::inference::ModelQueuePolicy* default_queue_policy);
  private:
  const ::inference::ModelQueuePolicy& _internal_default_queue_policy() const;
  ::inference::ModelQueuePolicy* _internal_mutable_default_queue_policy();
  public:
  void unsafe_arena_set_allocated_default_queue_policy(
      ::inference::ModelQueuePolicy* default_queue_policy);
  ::inference::ModelQueuePolicy* unsafe_arena_release_default_queue_policy();

  // uint64 max_queue_delay_microseconds = 2;
  void clear_max_queue_delay_microseconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_queue_delay_microseconds() const;
  void set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_queue_delay_microseconds() const;
  void _internal_set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool preserve_ordering = 3;
  void clear_preserve_ordering();
  bool preserve_ordering() const;
  void set_preserve_ordering(bool value);
  private:
  bool _internal_preserve_ordering() const;
  void _internal_set_preserve_ordering(bool value);
  public:

  // uint32 priority_levels = 4;
  void clear_priority_levels();
  ::PROTOBUF_NAMESPACE_ID::uint32 priority_levels() const;
  void set_priority_levels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_priority_levels() const;
  void _internal_set_priority_levels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 default_priority_level = 5;
  void clear_default_priority_level();
  ::PROTOBUF_NAMESPACE_ID::uint32 default_priority_level() const;
  void set_default_priority_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_default_priority_level() const;
  void _internal_set_default_priority_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelDynamicBatching)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > preferred_batch_size_;
  mutable std::atomic<int> _preferred_batch_size_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelDynamicBatching_PriorityQueuePolicyEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> priority_queue_policy_;
  ::inference::ModelQueuePolicy* default_queue_policy_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_queue_delay_microseconds_;
  bool preserve_ordering_;
  ::PROTOBUF_NAMESPACE_ID::uint32 priority_levels_;
  ::PROTOBUF_NAMESPACE_ID::uint32 default_priority_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_Control PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.Control) */ {
 public:
  inline ModelSequenceBatching_Control() : ModelSequenceBatching_Control(nullptr) {}
  virtual ~ModelSequenceBatching_Control();

  ModelSequenceBatching_Control(const ModelSequenceBatching_Control& from);
  ModelSequenceBatching_Control(ModelSequenceBatching_Control&& from) noexcept
    : ModelSequenceBatching_Control() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_Control& operator=(const ModelSequenceBatching_Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_Control& operator=(ModelSequenceBatching_Control&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelSequenceBatching_Control& default_instance();

  static inline const ModelSequenceBatching_Control* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_Control*>(
               &_ModelSequenceBatching_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ModelSequenceBatching_Control& a, ModelSequenceBatching_Control& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_Control* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_Control* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelSequenceBatching_Control* New() const final {
    return CreateMaybeMessage<ModelSequenceBatching_Control>(nullptr);
  }

  ModelSequenceBatching_Control* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelSequenceBatching_Control>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelSequenceBatching_Control& from);
  void MergeFrom(const ModelSequenceBatching_Control& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_Control* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.Control";
  }
  protected:
  explicit ModelSequenceBatching_Control(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelSequenceBatching_Control_Kind Kind;
  static constexpr Kind CONTROL_SEQUENCE_START =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_START;
  static constexpr Kind CONTROL_SEQUENCE_READY =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_READY;
  static constexpr Kind CONTROL_SEQUENCE_END =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_END;
  static constexpr Kind CONTROL_SEQUENCE_CORRID =
    ModelSequenceBatching_Control_Kind_CONTROL_SEQUENCE_CORRID;
  static inline bool Kind_IsValid(int value) {
    return ModelSequenceBatching_Control_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ModelSequenceBatching_Control_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ModelSequenceBatching_Control_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ModelSequenceBatching_Control_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ModelSequenceBatching_Control_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ModelSequenceBatching_Control_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return ModelSequenceBatching_Control_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInt32FalseTrueFieldNumber = 2,
    kFp32FalseTrueFieldNumber = 3,
    kKindFieldNumber = 1,
    kDataTypeFieldNumber = 4,
  };
  // repeated int32 int32_false_true = 2;
  int int32_false_true_size() const;
  private:
  int _internal_int32_false_true_size() const;
  public:
  void clear_int32_false_true();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_int32_false_true(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_int32_false_true() const;
  void _internal_add_int32_false_true(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_int32_false_true();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 int32_false_true(int index) const;
  void set_int32_false_true(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_int32_false_true(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      int32_false_true() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_int32_false_true();

  // repeated float fp32_false_true = 3;
  int fp32_false_true_size() const;
  private:
  int _internal_fp32_false_true_size() const;
  public:
  void clear_fp32_false_true();
  private:
  float _internal_fp32_false_true(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fp32_false_true() const;
  void _internal_add_fp32_false_true(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fp32_false_true();
  public:
  float fp32_false_true(int index) const;
  void set_fp32_false_true(int index, float value);
  void add_fp32_false_true(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fp32_false_true() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fp32_false_true();

  // .inference.ModelSequenceBatching.Control.Kind kind = 1;
  void clear_kind();
  ::inference::ModelSequenceBatching_Control_Kind kind() const;
  void set_kind(::inference::ModelSequenceBatching_Control_Kind value);
  private:
  ::inference::ModelSequenceBatching_Control_Kind _internal_kind() const;
  void _internal_set_kind(::inference::ModelSequenceBatching_Control_Kind value);
  public:

  // .inference.DataType data_type = 4;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.Control)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > int32_false_true_;
  mutable std::atomic<int> _int32_false_true_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fp32_false_true_;
  mutable std::atomic<int> _fp32_false_true_cached_byte_size_;
  int kind_;
  int data_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_ControlInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.ControlInput) */ {
 public:
  inline ModelSequenceBatching_ControlInput() : ModelSequenceBatching_ControlInput(nullptr) {}
  virtual ~ModelSequenceBatching_ControlInput();

  ModelSequenceBatching_ControlInput(const ModelSequenceBatching_ControlInput& from);
  ModelSequenceBatching_ControlInput(ModelSequenceBatching_ControlInput&& from) noexcept
    : ModelSequenceBatching_ControlInput() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_ControlInput& operator=(const ModelSequenceBatching_ControlInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_ControlInput& operator=(ModelSequenceBatching_ControlInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelSequenceBatching_ControlInput& default_instance();

  static inline const ModelSequenceBatching_ControlInput* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_ControlInput*>(
               &_ModelSequenceBatching_ControlInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ModelSequenceBatching_ControlInput& a, ModelSequenceBatching_ControlInput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_ControlInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_ControlInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelSequenceBatching_ControlInput* New() const final {
    return CreateMaybeMessage<ModelSequenceBatching_ControlInput>(nullptr);
  }

  ModelSequenceBatching_ControlInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelSequenceBatching_ControlInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelSequenceBatching_ControlInput& from);
  void MergeFrom(const ModelSequenceBatching_ControlInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_ControlInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.ControlInput";
  }
  protected:
  explicit ModelSequenceBatching_ControlInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .inference.ModelSequenceBatching.Control control = 2;
  int control_size() const;
  private:
  int _internal_control_size() const;
  public:
  void clear_control();
  ::inference::ModelSequenceBatching_Control* mutable_control(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >*
      mutable_control();
  private:
  const ::inference::ModelSequenceBatching_Control& _internal_control(int index) const;
  ::inference::ModelSequenceBatching_Control* _internal_add_control();
  public:
  const ::inference::ModelSequenceBatching_Control& control(int index) const;
  ::inference::ModelSequenceBatching_Control* add_control();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >&
      control() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.ControlInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control > control_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_StrategyDirect PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.StrategyDirect) */ {
 public:
  inline ModelSequenceBatching_StrategyDirect() : ModelSequenceBatching_StrategyDirect(nullptr) {}
  virtual ~ModelSequenceBatching_StrategyDirect();

  ModelSequenceBatching_StrategyDirect(const ModelSequenceBatching_StrategyDirect& from);
  ModelSequenceBatching_StrategyDirect(ModelSequenceBatching_StrategyDirect&& from) noexcept
    : ModelSequenceBatching_StrategyDirect() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_StrategyDirect& operator=(const ModelSequenceBatching_StrategyDirect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_StrategyDirect& operator=(ModelSequenceBatching_StrategyDirect&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelSequenceBatching_StrategyDirect& default_instance();

  static inline const ModelSequenceBatching_StrategyDirect* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_StrategyDirect*>(
               &_ModelSequenceBatching_StrategyDirect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ModelSequenceBatching_StrategyDirect& a, ModelSequenceBatching_StrategyDirect& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_StrategyDirect* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_StrategyDirect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelSequenceBatching_StrategyDirect* New() const final {
    return CreateMaybeMessage<ModelSequenceBatching_StrategyDirect>(nullptr);
  }

  ModelSequenceBatching_StrategyDirect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelSequenceBatching_StrategyDirect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelSequenceBatching_StrategyDirect& from);
  void MergeFrom(const ModelSequenceBatching_StrategyDirect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_StrategyDirect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.StrategyDirect";
  }
  protected:
  explicit ModelSequenceBatching_StrategyDirect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxQueueDelayMicrosecondsFieldNumber = 1,
    kMinimumSlotUtilizationFieldNumber = 2,
  };
  // uint64 max_queue_delay_microseconds = 1;
  void clear_max_queue_delay_microseconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_queue_delay_microseconds() const;
  void set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_queue_delay_microseconds() const;
  void _internal_set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float minimum_slot_utilization = 2;
  void clear_minimum_slot_utilization();
  float minimum_slot_utilization() const;
  void set_minimum_slot_utilization(float value);
  private:
  float _internal_minimum_slot_utilization() const;
  void _internal_set_minimum_slot_utilization(float value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.StrategyDirect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_queue_delay_microseconds_;
  float minimum_slot_utilization_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching_StrategyOldest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching.StrategyOldest) */ {
 public:
  inline ModelSequenceBatching_StrategyOldest() : ModelSequenceBatching_StrategyOldest(nullptr) {}
  virtual ~ModelSequenceBatching_StrategyOldest();

  ModelSequenceBatching_StrategyOldest(const ModelSequenceBatching_StrategyOldest& from);
  ModelSequenceBatching_StrategyOldest(ModelSequenceBatching_StrategyOldest&& from) noexcept
    : ModelSequenceBatching_StrategyOldest() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching_StrategyOldest& operator=(const ModelSequenceBatching_StrategyOldest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching_StrategyOldest& operator=(ModelSequenceBatching_StrategyOldest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelSequenceBatching_StrategyOldest& default_instance();

  static inline const ModelSequenceBatching_StrategyOldest* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching_StrategyOldest*>(
               &_ModelSequenceBatching_StrategyOldest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ModelSequenceBatching_StrategyOldest& a, ModelSequenceBatching_StrategyOldest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching_StrategyOldest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching_StrategyOldest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelSequenceBatching_StrategyOldest* New() const final {
    return CreateMaybeMessage<ModelSequenceBatching_StrategyOldest>(nullptr);
  }

  ModelSequenceBatching_StrategyOldest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelSequenceBatching_StrategyOldest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelSequenceBatching_StrategyOldest& from);
  void MergeFrom(const ModelSequenceBatching_StrategyOldest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching_StrategyOldest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching.StrategyOldest";
  }
  protected:
  explicit ModelSequenceBatching_StrategyOldest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreferredBatchSizeFieldNumber = 2,
    kMaxQueueDelayMicrosecondsFieldNumber = 3,
    kMaxCandidateSequencesFieldNumber = 1,
  };
  // repeated int32 preferred_batch_size = 2;
  int preferred_batch_size_size() const;
  private:
  int _internal_preferred_batch_size_size() const;
  public:
  void clear_preferred_batch_size();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_preferred_batch_size(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_preferred_batch_size() const;
  void _internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_preferred_batch_size();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 preferred_batch_size(int index) const;
  void set_preferred_batch_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      preferred_batch_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_preferred_batch_size();

  // uint64 max_queue_delay_microseconds = 3;
  void clear_max_queue_delay_microseconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_queue_delay_microseconds() const;
  void set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_queue_delay_microseconds() const;
  void _internal_set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 max_candidate_sequences = 1;
  void clear_max_candidate_sequences();
  ::PROTOBUF_NAMESPACE_ID::int32 max_candidate_sequences() const;
  void set_max_candidate_sequences(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_candidate_sequences() const;
  void _internal_set_max_candidate_sequences(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching.StrategyOldest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > preferred_batch_size_;
  mutable std::atomic<int> _preferred_batch_size_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_queue_delay_microseconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_candidate_sequences_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelSequenceBatching PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelSequenceBatching) */ {
 public:
  inline ModelSequenceBatching() : ModelSequenceBatching(nullptr) {}
  virtual ~ModelSequenceBatching();

  ModelSequenceBatching(const ModelSequenceBatching& from);
  ModelSequenceBatching(ModelSequenceBatching&& from) noexcept
    : ModelSequenceBatching() {
    *this = ::std::move(from);
  }

  inline ModelSequenceBatching& operator=(const ModelSequenceBatching& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelSequenceBatching& operator=(ModelSequenceBatching&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelSequenceBatching& default_instance();

  enum StrategyChoiceCase {
    kDirect = 3,
    kOldest = 4,
    STRATEGY_CHOICE_NOT_SET = 0,
  };

  static inline const ModelSequenceBatching* internal_default_instance() {
    return reinterpret_cast<const ModelSequenceBatching*>(
               &_ModelSequenceBatching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ModelSequenceBatching& a, ModelSequenceBatching& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelSequenceBatching* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelSequenceBatching* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelSequenceBatching* New() const final {
    return CreateMaybeMessage<ModelSequenceBatching>(nullptr);
  }

  ModelSequenceBatching* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelSequenceBatching>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelSequenceBatching& from);
  void MergeFrom(const ModelSequenceBatching& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelSequenceBatching* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelSequenceBatching";
  }
  protected:
  explicit ModelSequenceBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelSequenceBatching_Control Control;
  typedef ModelSequenceBatching_ControlInput ControlInput;
  typedef ModelSequenceBatching_StrategyDirect StrategyDirect;
  typedef ModelSequenceBatching_StrategyOldest StrategyOldest;

  // accessors -------------------------------------------------------

  enum : int {
    kControlInputFieldNumber = 2,
    kMaxSequenceIdleMicrosecondsFieldNumber = 1,
    kDirectFieldNumber = 3,
    kOldestFieldNumber = 4,
  };
  // repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
  int control_input_size() const;
  private:
  int _internal_control_input_size() const;
  public:
  void clear_control_input();
  ::inference::ModelSequenceBatching_ControlInput* mutable_control_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >*
      mutable_control_input();
  private:
  const ::inference::ModelSequenceBatching_ControlInput& _internal_control_input(int index) const;
  ::inference::ModelSequenceBatching_ControlInput* _internal_add_control_input();
  public:
  const ::inference::ModelSequenceBatching_ControlInput& control_input(int index) const;
  ::inference::ModelSequenceBatching_ControlInput* add_control_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >&
      control_input() const;

  // uint64 max_sequence_idle_microseconds = 1;
  void clear_max_sequence_idle_microseconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_sequence_idle_microseconds() const;
  void set_max_sequence_idle_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_sequence_idle_microseconds() const;
  void _internal_set_max_sequence_idle_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .inference.ModelSequenceBatching.StrategyDirect direct = 3;
  bool has_direct() const;
  private:
  bool _internal_has_direct() const;
  public:
  void clear_direct();
  const ::inference::ModelSequenceBatching_StrategyDirect& direct() const;
  ::inference::ModelSequenceBatching_StrategyDirect* release_direct();
  ::inference::ModelSequenceBatching_StrategyDirect* mutable_direct();
  void set_allocated_direct(::inference::ModelSequenceBatching_StrategyDirect* direct);
  private:
  const ::inference::ModelSequenceBatching_StrategyDirect& _internal_direct() const;
  ::inference::ModelSequenceBatching_StrategyDirect* _internal_mutable_direct();
  public:
  void unsafe_arena_set_allocated_direct(
      ::inference::ModelSequenceBatching_StrategyDirect* direct);
  ::inference::ModelSequenceBatching_StrategyDirect* unsafe_arena_release_direct();

  // .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
  bool has_oldest() const;
  private:
  bool _internal_has_oldest() const;
  public:
  void clear_oldest();
  const ::inference::ModelSequenceBatching_StrategyOldest& oldest() const;
  ::inference::ModelSequenceBatching_StrategyOldest* release_oldest();
  ::inference::ModelSequenceBatching_StrategyOldest* mutable_oldest();
  void set_allocated_oldest(::inference::ModelSequenceBatching_StrategyOldest* oldest);
  private:
  const ::inference::ModelSequenceBatching_StrategyOldest& _internal_oldest() const;
  ::inference::ModelSequenceBatching_StrategyOldest* _internal_mutable_oldest();
  public:
  void unsafe_arena_set_allocated_oldest(
      ::inference::ModelSequenceBatching_StrategyOldest* oldest);
  ::inference::ModelSequenceBatching_StrategyOldest* unsafe_arena_release_oldest();

  void clear_strategy_choice();
  StrategyChoiceCase strategy_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelSequenceBatching)
 private:
  class _Internal;
  void set_has_direct();
  void set_has_oldest();

  inline bool has_strategy_choice() const;
  inline void clear_has_strategy_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput > control_input_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_sequence_idle_microseconds_;
  union StrategyChoiceUnion {
    StrategyChoiceUnion() {}
    ::inference::ModelSequenceBatching_StrategyDirect* direct_;
    ::inference::ModelSequenceBatching_StrategyOldest* oldest_;
  } strategy_choice_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelEnsembling_Step_InputMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_InputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_InputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelEnsembling_Step_InputMapEntry_DoNotUse();
  explicit ModelEnsembling_Step_InputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelEnsembling_Step_InputMapEntry_DoNotUse& other);
  static const ModelEnsembling_Step_InputMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelEnsembling_Step_InputMapEntry_DoNotUse*>(&_ModelEnsembling_Step_InputMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.InputMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.InputMapEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[32];
  }

  public:
};

// -------------------------------------------------------------------

class ModelEnsembling_Step_OutputMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_OutputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelEnsembling_Step_OutputMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelEnsembling_Step_OutputMapEntry_DoNotUse();
  explicit ModelEnsembling_Step_OutputMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelEnsembling_Step_OutputMapEntry_DoNotUse& other);
  static const ModelEnsembling_Step_OutputMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelEnsembling_Step_OutputMapEntry_DoNotUse*>(&_ModelEnsembling_Step_OutputMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.OutputMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelEnsembling.Step.OutputMapEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[33];
  }

  public:
};

// -------------------------------------------------------------------

class ModelEnsembling_Step PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelEnsembling.Step) */ {
 public:
  inline ModelEnsembling_Step() : ModelEnsembling_Step(nullptr) {}
  virtual ~ModelEnsembling_Step();

  ModelEnsembling_Step(const ModelEnsembling_Step& from);
  ModelEnsembling_Step(ModelEnsembling_Step&& from) noexcept
    : ModelEnsembling_Step() {
    *this = ::std::move(from);
  }

  inline ModelEnsembling_Step& operator=(const ModelEnsembling_Step& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelEnsembling_Step& operator=(ModelEnsembling_Step&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelEnsembling_Step& default_instance();

  static inline const ModelEnsembling_Step* internal_default_instance() {
    return reinterpret_cast<const ModelEnsembling_Step*>(
               &_ModelEnsembling_Step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ModelEnsembling_Step& a, ModelEnsembling_Step& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelEnsembling_Step* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelEnsembling_Step* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelEnsembling_Step* New() const final {
    return CreateMaybeMessage<ModelEnsembling_Step>(nullptr);
  }

  ModelEnsembling_Step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelEnsembling_Step>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelEnsembling_Step& from);
  void MergeFrom(const ModelEnsembling_Step& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelEnsembling_Step* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelEnsembling.Step";
  }
  protected:
  explicit ModelEnsembling_Step(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputMapFieldNumber = 3,
    kOutputMapFieldNumber = 4,
    kModelNameFieldNumber = 1,
    kModelVersionFieldNumber = 2,
  };
  // map<string, string> input_map = 3;
  int input_map_size() const;
  private:
  int _internal_input_map_size() const;
  public:
  void clear_input_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_input_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_input_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      input_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_input_map();

  // map<string, string> output_map = 4;
  int output_map_size() const;
  private:
  int _internal_output_map_size() const;
  public:
  void clear_output_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_output_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_output_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      output_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_output_map();

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  void set_model_name(const std::string& value);
  void set_model_name(std::string&& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  std::string* mutable_model_name();
  std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // int64 model_version = 2;
  void clear_model_version();
  ::PROTOBUF_NAMESPACE_ID::int64 model_version() const;
  void set_model_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_model_version() const;
  void _internal_set_model_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelEnsembling.Step)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelEnsembling_Step_InputMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> input_map_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelEnsembling_Step_OutputMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> output_map_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 model_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelEnsembling PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelEnsembling) */ {
 public:
  inline ModelEnsembling() : ModelEnsembling(nullptr) {}
  virtual ~ModelEnsembling();

  ModelEnsembling(const ModelEnsembling& from);
  ModelEnsembling(ModelEnsembling&& from) noexcept
    : ModelEnsembling() {
    *this = ::std::move(from);
  }

  inline ModelEnsembling& operator=(const ModelEnsembling& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelEnsembling& operator=(ModelEnsembling&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelEnsembling& default_instance();

  static inline const ModelEnsembling* internal_default_instance() {
    return reinterpret_cast<const ModelEnsembling*>(
               &_ModelEnsembling_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ModelEnsembling& a, ModelEnsembling& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelEnsembling* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelEnsembling* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelEnsembling* New() const final {
    return CreateMaybeMessage<ModelEnsembling>(nullptr);
  }

  ModelEnsembling* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelEnsembling>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelEnsembling& from);
  void MergeFrom(const ModelEnsembling& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelEnsembling* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelEnsembling";
  }
  protected:
  explicit ModelEnsembling(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelEnsembling_Step Step;

  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
  };
  // repeated .inference.ModelEnsembling.Step step = 1;
  int step_size() const;
  private:
  int _internal_step_size() const;
  public:
  void clear_step();
  ::inference::ModelEnsembling_Step* mutable_step(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >*
      mutable_step();
  private:
  const ::inference::ModelEnsembling_Step& _internal_step(int index) const;
  ::inference::ModelEnsembling_Step* _internal_add_step();
  public:
  const ::inference::ModelEnsembling_Step& step(int index) const;
  ::inference::ModelEnsembling_Step* add_step();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >&
      step() const;

  // @@protoc_insertion_point(class_scope:inference.ModelEnsembling)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step > step_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelParameter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelParameter) */ {
 public:
  inline ModelParameter() : ModelParameter(nullptr) {}
  virtual ~ModelParameter();

  ModelParameter(const ModelParameter& from);
  ModelParameter(ModelParameter&& from) noexcept
    : ModelParameter() {
    *this = ::std::move(from);
  }

  inline ModelParameter& operator=(const ModelParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelParameter& operator=(ModelParameter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelParameter& default_instance();

  static inline const ModelParameter* internal_default_instance() {
    return reinterpret_cast<const ModelParameter*>(
               &_ModelParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ModelParameter& a, ModelParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelParameter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelParameter* New() const final {
    return CreateMaybeMessage<ModelParameter>(nullptr);
  }

  ModelParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelParameter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelParameter& from);
  void MergeFrom(const ModelParameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelParameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelParameter";
  }
  protected:
  explicit ModelParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValueFieldNumber = 1,
  };
  // string string_value = 1;
  void clear_string_value();
  const std::string& string_value() const;
  void set_string_value(const std::string& value);
  void set_string_value(std::string&& value);
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  std::string* mutable_string_value();
  std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelWarmup_Input PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelWarmup.Input) */ {
 public:
  inline ModelWarmup_Input() : ModelWarmup_Input(nullptr) {}
  virtual ~ModelWarmup_Input();

  ModelWarmup_Input(const ModelWarmup_Input& from);
  ModelWarmup_Input(ModelWarmup_Input&& from) noexcept
    : ModelWarmup_Input() {
    *this = ::std::move(from);
  }

  inline ModelWarmup_Input& operator=(const ModelWarmup_Input& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelWarmup_Input& operator=(ModelWarmup_Input&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelWarmup_Input& default_instance();

  enum InputDataTypeCase {
    kZeroData = 3,
    kRandomData = 4,
    kInputDataFile = 5,
    INPUT_DATA_TYPE_NOT_SET = 0,
  };

  static inline const ModelWarmup_Input* internal_default_instance() {
    return reinterpret_cast<const ModelWarmup_Input*>(
               &_ModelWarmup_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ModelWarmup_Input& a, ModelWarmup_Input& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelWarmup_Input* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelWarmup_Input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelWarmup_Input* New() const final {
    return CreateMaybeMessage<ModelWarmup_Input>(nullptr);
  }

  ModelWarmup_Input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelWarmup_Input>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelWarmup_Input& from);
  void MergeFrom(const ModelWarmup_Input& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelWarmup_Input* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelWarmup.Input";
  }
  protected:
  explicit ModelWarmup_Input(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 2,
    kDataTypeFieldNumber = 1,
    kZeroDataFieldNumber = 3,
    kRandomDataFieldNumber = 4,
    kInputDataFileFieldNumber = 5,
  };
  // repeated int64 dims = 2;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // .inference.DataType data_type = 1;
  void clear_data_type();
  ::inference::DataType data_type() const;
  void set_data_type(::inference::DataType value);
  private:
  ::inference::DataType _internal_data_type() const;
  void _internal_set_data_type(::inference::DataType value);
  public:

  // bool zero_data = 3;
  private:
  bool _internal_has_zero_data() const;
  public:
  void clear_zero_data();
  bool zero_data() const;
  void set_zero_data(bool value);
  private:
  bool _internal_zero_data() const;
  void _internal_set_zero_data(bool value);
  public:

  // bool random_data = 4;
  private:
  bool _internal_has_random_data() const;
  public:
  void clear_random_data();
  bool random_data() const;
  void set_random_data(bool value);
  private:
  bool _internal_random_data() const;
  void _internal_set_random_data(bool value);
  public:

  // string input_data_file = 5;
  private:
  bool _internal_has_input_data_file() const;
  public:
  void clear_input_data_file();
  const std::string& input_data_file() const;
  void set_input_data_file(const std::string& value);
  void set_input_data_file(std::string&& value);
  void set_input_data_file(const char* value);
  void set_input_data_file(const char* value, size_t size);
  std::string* mutable_input_data_file();
  std::string* release_input_data_file();
  void set_allocated_input_data_file(std::string* input_data_file);
  private:
  const std::string& _internal_input_data_file() const;
  void _internal_set_input_data_file(const std::string& value);
  std::string* _internal_mutable_input_data_file();
  public:

  void clear_input_data_type();
  InputDataTypeCase input_data_type_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelWarmup.Input)
 private:
  class _Internal;
  void set_has_zero_data();
  void set_has_random_data();
  void set_has_input_data_file();

  inline bool has_input_data_type() const;
  inline void clear_has_input_data_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  mutable std::atomic<int> _dims_cached_byte_size_;
  int data_type_;
  union InputDataTypeUnion {
    InputDataTypeUnion() {}
    bool zero_data_;
    bool random_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_data_file_;
  } input_data_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelWarmup_InputsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelWarmup_InputsEntry_DoNotUse, 
    std::string, ::inference::ModelWarmup_Input,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelWarmup_InputsEntry_DoNotUse, 
    std::string, ::inference::ModelWarmup_Input,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelWarmup_InputsEntry_DoNotUse();
  explicit ModelWarmup_InputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelWarmup_InputsEntry_DoNotUse& other);
  static const ModelWarmup_InputsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelWarmup_InputsEntry_DoNotUse*>(&_ModelWarmup_InputsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelWarmup.InputsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[38];
  }

  public:
};

// -------------------------------------------------------------------

class ModelWarmup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelWarmup) */ {
 public:
  inline ModelWarmup() : ModelWarmup(nullptr) {}
  virtual ~ModelWarmup();

  ModelWarmup(const ModelWarmup& from);
  ModelWarmup(ModelWarmup&& from) noexcept
    : ModelWarmup() {
    *this = ::std::move(from);
  }

  inline ModelWarmup& operator=(const ModelWarmup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelWarmup& operator=(ModelWarmup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelWarmup& default_instance();

  static inline const ModelWarmup* internal_default_instance() {
    return reinterpret_cast<const ModelWarmup*>(
               &_ModelWarmup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ModelWarmup& a, ModelWarmup& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelWarmup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelWarmup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelWarmup* New() const final {
    return CreateMaybeMessage<ModelWarmup>(nullptr);
  }

  ModelWarmup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelWarmup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelWarmup& from);
  void MergeFrom(const ModelWarmup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelWarmup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelWarmup";
  }
  protected:
  explicit ModelWarmup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelWarmup_Input Input;

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 3,
    kNameFieldNumber = 1,
    kBatchSizeFieldNumber = 2,
  };
  // map<string, .inference.ModelWarmup.Input> inputs = 3;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
      _internal_inputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
      _internal_mutable_inputs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
      inputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
      mutable_inputs();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 batch_size = 2;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelWarmup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelWarmup_InputsEntry_DoNotUse,
      std::string, ::inference::ModelWarmup_Input,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> inputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOperations PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelOperations) */ {
 public:
  inline ModelOperations() : ModelOperations(nullptr) {}
  virtual ~ModelOperations();

  ModelOperations(const ModelOperations& from);
  ModelOperations(ModelOperations&& from) noexcept
    : ModelOperations() {
    *this = ::std::move(from);
  }

  inline ModelOperations& operator=(const ModelOperations& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOperations& operator=(ModelOperations&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOperations& default_instance();

  static inline const ModelOperations* internal_default_instance() {
    return reinterpret_cast<const ModelOperations*>(
               &_ModelOperations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ModelOperations& a, ModelOperations& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOperations* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOperations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOperations* New() const final {
    return CreateMaybeMessage<ModelOperations>(nullptr);
  }

  ModelOperations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOperations>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOperations& from);
  void MergeFrom(const ModelOperations& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOperations* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelOperations";
  }
  protected:
  explicit ModelOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpLibraryFilenameFieldNumber = 1,
  };
  // repeated string op_library_filename = 1;
  int op_library_filename_size() const;
  private:
  int _internal_op_library_filename_size() const;
  public:
  void clear_op_library_filename();
  const std::string& op_library_filename(int index) const;
  std::string* mutable_op_library_filename(int index);
  void set_op_library_filename(int index, const std::string& value);
  void set_op_library_filename(int index, std::string&& value);
  void set_op_library_filename(int index, const char* value);
  void set_op_library_filename(int index, const char* value, size_t size);
  std::string* add_op_library_filename();
  void add_op_library_filename(const std::string& value);
  void add_op_library_filename(std::string&& value);
  void add_op_library_filename(const char* value);
  void add_op_library_filename(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& op_library_filename() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_op_library_filename();
  private:
  const std::string& _internal_op_library_filename(int index) const;
  std::string* _internal_add_op_library_filename();
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelOperations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> op_library_filename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelTransactionPolicy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelTransactionPolicy) */ {
 public:
  inline ModelTransactionPolicy() : ModelTransactionPolicy(nullptr) {}
  virtual ~ModelTransactionPolicy();

  ModelTransactionPolicy(const ModelTransactionPolicy& from);
  ModelTransactionPolicy(ModelTransactionPolicy&& from) noexcept
    : ModelTransactionPolicy() {
    *this = ::std::move(from);
  }

  inline ModelTransactionPolicy& operator=(const ModelTransactionPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelTransactionPolicy& operator=(ModelTransactionPolicy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelTransactionPolicy& default_instance();

  static inline const ModelTransactionPolicy* internal_default_instance() {
    return reinterpret_cast<const ModelTransactionPolicy*>(
               &_ModelTransactionPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ModelTransactionPolicy& a, ModelTransactionPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelTransactionPolicy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelTransactionPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelTransactionPolicy* New() const final {
    return CreateMaybeMessage<ModelTransactionPolicy>(nullptr);
  }

  ModelTransactionPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelTransactionPolicy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelTransactionPolicy& from);
  void MergeFrom(const ModelTransactionPolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelTransactionPolicy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelTransactionPolicy";
  }
  protected:
  explicit ModelTransactionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoupledFieldNumber = 1,
  };
  // bool decoupled = 1;
  void clear_decoupled();
  bool decoupled() const;
  void set_decoupled(bool value);
  private:
  bool _internal_decoupled() const;
  void _internal_set_decoupled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inference.ModelTransactionPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool decoupled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelConfig_CcModelFilenamesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_CcModelFilenamesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_CcModelFilenamesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelConfig_CcModelFilenamesEntry_DoNotUse();
  explicit ModelConfig_CcModelFilenamesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelConfig_CcModelFilenamesEntry_DoNotUse& other);
  static const ModelConfig_CcModelFilenamesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelConfig_CcModelFilenamesEntry_DoNotUse*>(&_ModelConfig_CcModelFilenamesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.CcModelFilenamesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.CcModelFilenamesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[42];
  }

  public:
};

// -------------------------------------------------------------------

class ModelConfig_MetricTagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_MetricTagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_MetricTagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ModelConfig_MetricTagsEntry_DoNotUse();
  explicit ModelConfig_MetricTagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelConfig_MetricTagsEntry_DoNotUse& other);
  static const ModelConfig_MetricTagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelConfig_MetricTagsEntry_DoNotUse*>(&_ModelConfig_MetricTagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.MetricTagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.MetricTagsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[43];
  }

  public:
};

// -------------------------------------------------------------------

class ModelConfig_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelConfig_ParametersEntry_DoNotUse, 
    std::string, ::inference::ModelParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelConfig_ParametersEntry_DoNotUse();
  explicit ModelConfig_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelConfig_ParametersEntry_DoNotUse& other);
  static const ModelConfig_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelConfig_ParametersEntry_DoNotUse*>(&_ModelConfig_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "inference.ModelConfig.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[44];
  }

  public:
};

// -------------------------------------------------------------------

class ModelConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inference.ModelConfig) */ {
 public:
  inline ModelConfig() : ModelConfig(nullptr) {}
  virtual ~ModelConfig();

  ModelConfig(const ModelConfig& from);
  ModelConfig(ModelConfig&& from) noexcept
    : ModelConfig() {
    *this = ::std::move(from);
  }

  inline ModelConfig& operator=(const ModelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfig& operator=(ModelConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelConfig& default_instance();

  enum SchedulingChoiceCase {
    kDynamicBatching = 11,
    kSequenceBatching = 13,
    kEnsembleScheduling = 15,
    SCHEDULING_CHOICE_NOT_SET = 0,
  };

  static inline const ModelConfig* internal_default_instance() {
    return reinterpret_cast<const ModelConfig*>(
               &_ModelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ModelConfig& a, ModelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelConfig* New() const final {
    return CreateMaybeMessage<ModelConfig>(nullptr);
  }

  ModelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelConfig& from);
  void MergeFrom(const ModelConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inference.ModelConfig";
  }
  protected:
  explicit ModelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_5fconfig_2eproto);
    return ::descriptor_table_model_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 5,
    kOutputFieldNumber = 6,
    kInstanceGroupFieldNumber = 7,
    kCcModelFilenamesFieldNumber = 9,
    kMetricTagsFieldNumber = 10,
    kParametersFieldNumber = 14,
    kModelWarmupFieldNumber = 16,
    kBatchInputFieldNumber = 20,
    kBatchOutputFieldNumber = 21,
    kNameFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kDefaultModelFilenameFieldNumber = 8,
    kBackendFieldNumber = 17,
    kVersionPolicyFieldNumber = 3,
    kOptimizationFieldNumber = 12,
    kModelOperationsFieldNumber = 18,
    kModelTransactionPolicyFieldNumber = 19,
    kMaxBatchSizeFieldNumber = 4,
    kDynamicBatchingFieldNumber = 11,
    kSequenceBatchingFieldNumber = 13,
    kEnsembleSchedulingFieldNumber = 15,
  };
  // repeated .inference.ModelInput input = 5;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  ::inference::ModelInput* mutable_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >*
      mutable_input();
  private:
  const ::inference::ModelInput& _internal_input(int index) const;
  ::inference::ModelInput* _internal_add_input();
  public:
  const ::inference::ModelInput& input(int index) const;
  ::inference::ModelInput* add_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >&
      input() const;

  // repeated .inference.ModelOutput output = 6;
  int output_size() const;
  private:
  int _internal_output_size() const;
  public:
  void clear_output();
  ::inference::ModelOutput* mutable_output(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >*
      mutable_output();
  private:
  const ::inference::ModelOutput& _internal_output(int index) const;
  ::inference::ModelOutput* _internal_add_output();
  public:
  const ::inference::ModelOutput& output(int index) const;
  ::inference::ModelOutput* add_output();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >&
      output() const;

  // repeated .inference.ModelInstanceGroup instance_group = 7;
  int instance_group_size() const;
  private:
  int _internal_instance_group_size() const;
  public:
  void clear_instance_group();
  ::inference::ModelInstanceGroup* mutable_instance_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >*
      mutable_instance_group();
  private:
  const ::inference::ModelInstanceGroup& _internal_instance_group(int index) const;
  ::inference::ModelInstanceGroup* _internal_add_instance_group();
  public:
  const ::inference::ModelInstanceGroup& instance_group(int index) const;
  ::inference::ModelInstanceGroup* add_instance_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >&
      instance_group() const;

  // map<string, string> cc_model_filenames = 9;
  int cc_model_filenames_size() const;
  private:
  int _internal_cc_model_filenames_size() const;
  public:
  void clear_cc_model_filenames();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_cc_model_filenames() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_cc_model_filenames();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      cc_model_filenames() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_cc_model_filenames();

  // map<string, string> metric_tags = 10;
  int metric_tags_size() const;
  private:
  int _internal_metric_tags_size() const;
  public:
  void clear_metric_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metric_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metric_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metric_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metric_tags();

  // map<string, .inference.ModelParameter> parameters = 14;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
      mutable_parameters();

  // repeated .inference.ModelWarmup model_warmup = 16;
  int model_warmup_size() const;
  private:
  int _internal_model_warmup_size() const;
  public:
  void clear_model_warmup();
  ::inference::ModelWarmup* mutable_model_warmup(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >*
      mutable_model_warmup();
  private:
  const ::inference::ModelWarmup& _internal_model_warmup(int index) const;
  ::inference::ModelWarmup* _internal_add_model_warmup();
  public:
  const ::inference::ModelWarmup& model_warmup(int index) const;
  ::inference::ModelWarmup* add_model_warmup();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >&
      model_warmup() const;

  // repeated .inference.BatchInput batch_input = 20;
  int batch_input_size() const;
  private:
  int _internal_batch_input_size() const;
  public:
  void clear_batch_input();
  ::inference::BatchInput* mutable_batch_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >*
      mutable_batch_input();
  private:
  const ::inference::BatchInput& _internal_batch_input(int index) const;
  ::inference::BatchInput* _internal_add_batch_input();
  public:
  const ::inference::BatchInput& batch_input(int index) const;
  ::inference::BatchInput* add_batch_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >&
      batch_input() const;

  // repeated .inference.BatchOutput batch_output = 21;
  int batch_output_size() const;
  private:
  int _internal_batch_output_size() const;
  public:
  void clear_batch_output();
  ::inference::BatchOutput* mutable_batch_output(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >*
      mutable_batch_output();
  private:
  const ::inference::BatchOutput& _internal_batch_output(int index) const;
  ::inference::BatchOutput* _internal_add_batch_output();
  public:
  const ::inference::BatchOutput& batch_output(int index) const;
  ::inference::BatchOutput* add_batch_output();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >&
      batch_output() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string platform = 2;
  void clear_platform();
  const std::string& platform() const;
  void set_platform(const std::string& value);
  void set_platform(std::string&& value);
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  std::string* mutable_platform();
  std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // string default_model_filename = 8;
  void clear_default_model_filename();
  const std::string& default_model_filename() const;
  void set_default_model_filename(const std::string& value);
  void set_default_model_filename(std::string&& value);
  void set_default_model_filename(const char* value);
  void set_default_model_filename(const char* value, size_t size);
  std::string* mutable_default_model_filename();
  std::string* release_default_model_filename();
  void set_allocated_default_model_filename(std::string* default_model_filename);
  private:
  const std::string& _internal_default_model_filename() const;
  void _internal_set_default_model_filename(const std::string& value);
  std::string* _internal_mutable_default_model_filename();
  public:

  // string backend = 17;
  void clear_backend();
  const std::string& backend() const;
  void set_backend(const std::string& value);
  void set_backend(std::string&& value);
  void set_backend(const char* value);
  void set_backend(const char* value, size_t size);
  std::string* mutable_backend();
  std::string* release_backend();
  void set_allocated_backend(std::string* backend);
  private:
  const std::string& _internal_backend() const;
  void _internal_set_backend(const std::string& value);
  std::string* _internal_mutable_backend();
  public:

  // .inference.ModelVersionPolicy version_policy = 3;
  bool has_version_policy() const;
  private:
  bool _internal_has_version_policy() const;
  public:
  void clear_version_policy();
  const ::inference::ModelVersionPolicy& version_policy() const;
  ::inference::ModelVersionPolicy* release_version_policy();
  ::inference::ModelVersionPolicy* mutable_version_policy();
  void set_allocated_version_policy(::inference::ModelVersionPolicy* version_policy);
  private:
  const ::inference::ModelVersionPolicy& _internal_version_policy() const;
  ::inference::ModelVersionPolicy* _internal_mutable_version_policy();
  public:
  void unsafe_arena_set_allocated_version_policy(
      ::inference::ModelVersionPolicy* version_policy);
  ::inference::ModelVersionPolicy* unsafe_arena_release_version_policy();

  // .inference.ModelOptimizationPolicy optimization = 12;
  bool has_optimization() const;
  private:
  bool _internal_has_optimization() const;
  public:
  void clear_optimization();
  const ::inference::ModelOptimizationPolicy& optimization() const;
  ::inference::ModelOptimizationPolicy* release_optimization();
  ::inference::ModelOptimizationPolicy* mutable_optimization();
  void set_allocated_optimization(::inference::ModelOptimizationPolicy* optimization);
  private:
  const ::inference::ModelOptimizationPolicy& _internal_optimization() const;
  ::inference::ModelOptimizationPolicy* _internal_mutable_optimization();
  public:
  void unsafe_arena_set_allocated_optimization(
      ::inference::ModelOptimizationPolicy* optimization);
  ::inference::ModelOptimizationPolicy* unsafe_arena_release_optimization();

  // .inference.ModelOperations model_operations = 18;
  bool has_model_operations() const;
  private:
  bool _internal_has_model_operations() const;
  public:
  void clear_model_operations();
  const ::inference::ModelOperations& model_operations() const;
  ::inference::ModelOperations* release_model_operations();
  ::inference::ModelOperations* mutable_model_operations();
  void set_allocated_model_operations(::inference::ModelOperations* model_operations);
  private:
  const ::inference::ModelOperations& _internal_model_operations() const;
  ::inference::ModelOperations* _internal_mutable_model_operations();
  public:
  void unsafe_arena_set_allocated_model_operations(
      ::inference::ModelOperations* model_operations);
  ::inference::ModelOperations* unsafe_arena_release_model_operations();

  // .inference.ModelTransactionPolicy model_transaction_policy = 19;
  bool has_model_transaction_policy() const;
  private:
  bool _internal_has_model_transaction_policy() const;
  public:
  void clear_model_transaction_policy();
  const ::inference::ModelTransactionPolicy& model_transaction_policy() const;
  ::inference::ModelTransactionPolicy* release_model_transaction_policy();
  ::inference::ModelTransactionPolicy* mutable_model_transaction_policy();
  void set_allocated_model_transaction_policy(::inference::ModelTransactionPolicy* model_transaction_policy);
  private:
  const ::inference::ModelTransactionPolicy& _internal_model_transaction_policy() const;
  ::inference::ModelTransactionPolicy* _internal_mutable_model_transaction_policy();
  public:
  void unsafe_arena_set_allocated_model_transaction_policy(
      ::inference::ModelTransactionPolicy* model_transaction_policy);
  ::inference::ModelTransactionPolicy* unsafe_arena_release_model_transaction_policy();

  // int32 max_batch_size = 4;
  void clear_max_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_batch_size() const;
  void set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_batch_size() const;
  void _internal_set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .inference.ModelDynamicBatching dynamic_batching = 11;
  bool has_dynamic_batching() const;
  private:
  bool _internal_has_dynamic_batching() const;
  public:
  void clear_dynamic_batching();
  const ::inference::ModelDynamicBatching& dynamic_batching() const;
  ::inference::ModelDynamicBatching* release_dynamic_batching();
  ::inference::ModelDynamicBatching* mutable_dynamic_batching();
  void set_allocated_dynamic_batching(::inference::ModelDynamicBatching* dynamic_batching);
  private:
  const ::inference::ModelDynamicBatching& _internal_dynamic_batching() const;
  ::inference::ModelDynamicBatching* _internal_mutable_dynamic_batching();
  public:
  void unsafe_arena_set_allocated_dynamic_batching(
      ::inference::ModelDynamicBatching* dynamic_batching);
  ::inference::ModelDynamicBatching* unsafe_arena_release_dynamic_batching();

  // .inference.ModelSequenceBatching sequence_batching = 13;
  bool has_sequence_batching() const;
  private:
  bool _internal_has_sequence_batching() const;
  public:
  void clear_sequence_batching();
  const ::inference::ModelSequenceBatching& sequence_batching() const;
  ::inference::ModelSequenceBatching* release_sequence_batching();
  ::inference::ModelSequenceBatching* mutable_sequence_batching();
  void set_allocated_sequence_batching(::inference::ModelSequenceBatching* sequence_batching);
  private:
  const ::inference::ModelSequenceBatching& _internal_sequence_batching() const;
  ::inference::ModelSequenceBatching* _internal_mutable_sequence_batching();
  public:
  void unsafe_arena_set_allocated_sequence_batching(
      ::inference::ModelSequenceBatching* sequence_batching);
  ::inference::ModelSequenceBatching* unsafe_arena_release_sequence_batching();

  // .inference.ModelEnsembling ensemble_scheduling = 15;
  bool has_ensemble_scheduling() const;
  private:
  bool _internal_has_ensemble_scheduling() const;
  public:
  void clear_ensemble_scheduling();
  const ::inference::ModelEnsembling& ensemble_scheduling() const;
  ::inference::ModelEnsembling* release_ensemble_scheduling();
  ::inference::ModelEnsembling* mutable_ensemble_scheduling();
  void set_allocated_ensemble_scheduling(::inference::ModelEnsembling* ensemble_scheduling);
  private:
  const ::inference::ModelEnsembling& _internal_ensemble_scheduling() const;
  ::inference::ModelEnsembling* _internal_mutable_ensemble_scheduling();
  public:
  void unsafe_arena_set_allocated_ensemble_scheduling(
      ::inference::ModelEnsembling* ensemble_scheduling);
  ::inference::ModelEnsembling* unsafe_arena_release_ensemble_scheduling();

  void clear_scheduling_choice();
  SchedulingChoiceCase scheduling_choice_case() const;
  // @@protoc_insertion_point(class_scope:inference.ModelConfig)
 private:
  class _Internal;
  void set_has_dynamic_batching();
  void set_has_sequence_batching();
  void set_has_ensemble_scheduling();

  inline bool has_scheduling_choice() const;
  inline void clear_has_scheduling_choice();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput > input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput > output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup > instance_group_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelConfig_CcModelFilenamesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> cc_model_filenames_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelConfig_MetricTagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metric_tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelConfig_ParametersEntry_DoNotUse,
      std::string, ::inference::ModelParameter,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup > model_warmup_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput > batch_input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput > batch_output_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_model_filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backend_;
  ::inference::ModelVersionPolicy* version_policy_;
  ::inference::ModelOptimizationPolicy* optimization_;
  ::inference::ModelOperations* model_operations_;
  ::inference::ModelTransactionPolicy* model_transaction_policy_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_batch_size_;
  union SchedulingChoiceUnion {
    SchedulingChoiceUnion() {}
    ::inference::ModelDynamicBatching* dynamic_batching_;
    ::inference::ModelSequenceBatching* sequence_batching_;
    ::inference::ModelEnsembling* ensemble_scheduling_;
  } scheduling_choice_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_model_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModelRateLimiter_Resource

// string name = 1;
inline void ModelRateLimiter_Resource::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelRateLimiter_Resource::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.Resource.name)
  return _internal_name();
}
inline void ModelRateLimiter_Resource::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.Resource.name)
}
inline std::string* ModelRateLimiter_Resource::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelRateLimiter.Resource.name)
  return _internal_mutable_name();
}
inline const std::string& ModelRateLimiter_Resource::_internal_name() const {
  return name_.Get();
}
inline void ModelRateLimiter_Resource::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelRateLimiter_Resource::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelRateLimiter.Resource.name)
}
inline void ModelRateLimiter_Resource::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelRateLimiter.Resource.name)
}
inline void ModelRateLimiter_Resource::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelRateLimiter.Resource.name)
}
inline std::string* ModelRateLimiter_Resource::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelRateLimiter_Resource::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelRateLimiter.Resource.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelRateLimiter_Resource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelRateLimiter.Resource.name)
}

// bool global = 2;
inline void ModelRateLimiter_Resource::clear_global() {
  global_ = false;
}
inline bool ModelRateLimiter_Resource::_internal_global() const {
  return global_;
}
inline bool ModelRateLimiter_Resource::global() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.Resource.global)
  return _internal_global();
}
inline void ModelRateLimiter_Resource::_internal_set_global(bool value) {
  
  global_ = value;
}
inline void ModelRateLimiter_Resource::set_global(bool value) {
  _internal_set_global(value);
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.Resource.global)
}

// uint32 count = 3;
inline void ModelRateLimiter_Resource::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelRateLimiter_Resource::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelRateLimiter_Resource::count() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.Resource.count)
  return _internal_count();
}
inline void ModelRateLimiter_Resource::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
}
inline void ModelRateLimiter_Resource::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.Resource.count)
}

// -------------------------------------------------------------------

// ModelRateLimiter

// repeated .inference.ModelRateLimiter.Resource resources = 1;
inline int ModelRateLimiter::_internal_resources_size() const {
  return resources_.size();
}
inline int ModelRateLimiter::resources_size() const {
  return _internal_resources_size();
}
inline void ModelRateLimiter::clear_resources() {
  resources_.Clear();
}
inline ::inference::ModelRateLimiter_Resource* ModelRateLimiter::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelRateLimiter.resources)
  return resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >*
ModelRateLimiter::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelRateLimiter.resources)
  return &resources_;
}
inline const ::inference::ModelRateLimiter_Resource& ModelRateLimiter::_internal_resources(int index) const {
  return resources_.Get(index);
}
inline const ::inference::ModelRateLimiter_Resource& ModelRateLimiter::resources(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.resources)
  return _internal_resources(index);
}
inline ::inference::ModelRateLimiter_Resource* ModelRateLimiter::_internal_add_resources() {
  return resources_.Add();
}
inline ::inference::ModelRateLimiter_Resource* ModelRateLimiter::add_resources() {
  // @@protoc_insertion_point(field_add:inference.ModelRateLimiter.resources)
  return _internal_add_resources();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelRateLimiter_Resource >&
ModelRateLimiter::resources() const {
  // @@protoc_insertion_point(field_list:inference.ModelRateLimiter.resources)
  return resources_;
}

// uint32 priority = 2;
inline void ModelRateLimiter::clear_priority() {
  priority_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelRateLimiter::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelRateLimiter::priority() const {
  // @@protoc_insertion_point(field_get:inference.ModelRateLimiter.priority)
  return _internal_priority();
}
inline void ModelRateLimiter::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  priority_ = value;
}
inline void ModelRateLimiter::set_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:inference.ModelRateLimiter.priority)
}

// -------------------------------------------------------------------

// ModelInstanceGroup

// string name = 1;
inline void ModelInstanceGroup::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelInstanceGroup::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.name)
  return _internal_name();
}
inline void ModelInstanceGroup::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.name)
}
inline std::string* ModelInstanceGroup::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.name)
  return _internal_mutable_name();
}
inline const std::string& ModelInstanceGroup::_internal_name() const {
  return name_.Get();
}
inline void ModelInstanceGroup::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelInstanceGroup::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelInstanceGroup.name)
}
inline void ModelInstanceGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelInstanceGroup.name)
}
inline void ModelInstanceGroup::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInstanceGroup.name)
}
inline std::string* ModelInstanceGroup::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelInstanceGroup::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInstanceGroup.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelInstanceGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInstanceGroup.name)
}

// .inference.ModelInstanceGroup.Kind kind = 4;
inline void ModelInstanceGroup::clear_kind() {
  kind_ = 0;
}
inline ::inference::ModelInstanceGroup_Kind ModelInstanceGroup::_internal_kind() const {
  return static_cast< ::inference::ModelInstanceGroup_Kind >(kind_);
}
inline ::inference::ModelInstanceGroup_Kind ModelInstanceGroup::kind() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.kind)
  return _internal_kind();
}
inline void ModelInstanceGroup::_internal_set_kind(::inference::ModelInstanceGroup_Kind value) {
  
  kind_ = value;
}
inline void ModelInstanceGroup::set_kind(::inference::ModelInstanceGroup_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.kind)
}

// int32 count = 2;
inline void ModelInstanceGroup::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInstanceGroup::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInstanceGroup::count() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.count)
  return _internal_count();
}
inline void ModelInstanceGroup::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void ModelInstanceGroup::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.count)
}

// .inference.ModelRateLimiter rate_limiter = 6;
inline bool ModelInstanceGroup::_internal_has_rate_limiter() const {
  return this != internal_default_instance() && rate_limiter_ != nullptr;
}
inline bool ModelInstanceGroup::has_rate_limiter() const {
  return _internal_has_rate_limiter();
}
inline void ModelInstanceGroup::clear_rate_limiter() {
  if (GetArena() == nullptr && rate_limiter_ != nullptr) {
    delete rate_limiter_;
  }
  rate_limiter_ = nullptr;
}
inline const ::inference::ModelRateLimiter& ModelInstanceGroup::_internal_rate_limiter() const {
  const ::inference::ModelRateLimiter* p = rate_limiter_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelRateLimiter&>(
      ::inference::_ModelRateLimiter_default_instance_);
}
inline const ::inference::ModelRateLimiter& ModelInstanceGroup::rate_limiter() const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.rate_limiter)
  return _internal_rate_limiter();
}
inline void ModelInstanceGroup::unsafe_arena_set_allocated_rate_limiter(
    ::inference::ModelRateLimiter* rate_limiter) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rate_limiter_);
  }
  rate_limiter_ = rate_limiter;
  if (rate_limiter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelInstanceGroup.rate_limiter)
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::release_rate_limiter() {
  
  ::inference::ModelRateLimiter* temp = rate_limiter_;
  rate_limiter_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::unsafe_arena_release_rate_limiter() {
  // @@protoc_insertion_point(field_release:inference.ModelInstanceGroup.rate_limiter)
  
  ::inference::ModelRateLimiter* temp = rate_limiter_;
  rate_limiter_ = nullptr;
  return temp;
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::_internal_mutable_rate_limiter() {
  
  if (rate_limiter_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelRateLimiter>(GetArena());
    rate_limiter_ = p;
  }
  return rate_limiter_;
}
inline ::inference::ModelRateLimiter* ModelInstanceGroup::mutable_rate_limiter() {
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.rate_limiter)
  return _internal_mutable_rate_limiter();
}
inline void ModelInstanceGroup::set_allocated_rate_limiter(::inference::ModelRateLimiter* rate_limiter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rate_limiter_;
  }
  if (rate_limiter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rate_limiter);
    if (message_arena != submessage_arena) {
      rate_limiter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rate_limiter, submessage_arena);
    }
    
  } else {
    
  }
  rate_limiter_ = rate_limiter;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInstanceGroup.rate_limiter)
}

// repeated int32 gpus = 3;
inline int ModelInstanceGroup::_internal_gpus_size() const {
  return gpus_.size();
}
inline int ModelInstanceGroup::gpus_size() const {
  return _internal_gpus_size();
}
inline void ModelInstanceGroup::clear_gpus() {
  gpus_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInstanceGroup::_internal_gpus(int index) const {
  return gpus_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInstanceGroup::gpus(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.gpus)
  return _internal_gpus(index);
}
inline void ModelInstanceGroup::set_gpus(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  gpus_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.gpus)
}
inline void ModelInstanceGroup::_internal_add_gpus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  gpus_.Add(value);
}
inline void ModelInstanceGroup::add_gpus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_gpus(value);
  // @@protoc_insertion_point(field_add:inference.ModelInstanceGroup.gpus)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelInstanceGroup::_internal_gpus() const {
  return gpus_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelInstanceGroup::gpus() const {
  // @@protoc_insertion_point(field_list:inference.ModelInstanceGroup.gpus)
  return _internal_gpus();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelInstanceGroup::_internal_mutable_gpus() {
  return &gpus_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelInstanceGroup::mutable_gpus() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInstanceGroup.gpus)
  return _internal_mutable_gpus();
}

// repeated string profile = 5;
inline int ModelInstanceGroup::_internal_profile_size() const {
  return profile_.size();
}
inline int ModelInstanceGroup::profile_size() const {
  return _internal_profile_size();
}
inline void ModelInstanceGroup::clear_profile() {
  profile_.Clear();
}
inline std::string* ModelInstanceGroup::add_profile() {
  // @@protoc_insertion_point(field_add_mutable:inference.ModelInstanceGroup.profile)
  return _internal_add_profile();
}
inline const std::string& ModelInstanceGroup::_internal_profile(int index) const {
  return profile_.Get(index);
}
inline const std::string& ModelInstanceGroup::profile(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInstanceGroup.profile)
  return _internal_profile(index);
}
inline std::string* ModelInstanceGroup::mutable_profile(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelInstanceGroup.profile)
  return profile_.Mutable(index);
}
inline void ModelInstanceGroup::set_profile(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.profile)
  profile_.Mutable(index)->assign(value);
}
inline void ModelInstanceGroup::set_profile(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:inference.ModelInstanceGroup.profile)
  profile_.Mutable(index)->assign(std::move(value));
}
inline void ModelInstanceGroup::set_profile(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  profile_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::set_profile(int index, const char* value, size_t size) {
  profile_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInstanceGroup.profile)
}
inline std::string* ModelInstanceGroup::_internal_add_profile() {
  return profile_.Add();
}
inline void ModelInstanceGroup::add_profile(const std::string& value) {
  profile_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::add_profile(std::string&& value) {
  profile_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::add_profile(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  profile_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelInstanceGroup.profile)
}
inline void ModelInstanceGroup::add_profile(const char* value, size_t size) {
  profile_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelInstanceGroup.profile)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInstanceGroup::profile() const {
  // @@protoc_insertion_point(field_list:inference.ModelInstanceGroup.profile)
  return profile_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInstanceGroup::mutable_profile() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInstanceGroup.profile)
  return &profile_;
}

// -------------------------------------------------------------------

// ModelTensorReshape

// repeated int64 shape = 1;
inline int ModelTensorReshape::_internal_shape_size() const {
  return shape_.size();
}
inline int ModelTensorReshape::shape_size() const {
  return _internal_shape_size();
}
inline void ModelTensorReshape::clear_shape() {
  shape_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelTensorReshape::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelTensorReshape::shape(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelTensorReshape.shape)
  return _internal_shape(index);
}
inline void ModelTensorReshape::set_shape(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelTensorReshape.shape)
}
inline void ModelTensorReshape::_internal_add_shape(::PROTOBUF_NAMESPACE_ID::int64 value) {
  shape_.Add(value);
}
inline void ModelTensorReshape::add_shape(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:inference.ModelTensorReshape.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelTensorReshape::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelTensorReshape::shape() const {
  // @@protoc_insertion_point(field_list:inference.ModelTensorReshape.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelTensorReshape::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelTensorReshape::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelTensorReshape.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// ModelInput

// string name = 1;
inline void ModelInput::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelInput::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.name)
  return _internal_name();
}
inline void ModelInput::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.name)
}
inline std::string* ModelInput::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelInput.name)
  return _internal_mutable_name();
}
inline const std::string& ModelInput::_internal_name() const {
  return name_.Get();
}
inline void ModelInput::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelInput::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelInput.name)
}
inline void ModelInput::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelInput.name)
}
inline void ModelInput::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelInput.name)
}
inline std::string* ModelInput::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelInput::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelInput.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelInput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInput.name)
}

// .inference.DataType data_type = 2;
inline void ModelInput::clear_data_type() {
  data_type_ = 0;
}
inline ::inference::DataType ModelInput::_internal_data_type() const {
  return static_cast< ::inference::DataType >(data_type_);
}
inline ::inference::DataType ModelInput::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.data_type)
  return _internal_data_type();
}
inline void ModelInput::_internal_set_data_type(::inference::DataType value) {
  
  data_type_ = value;
}
inline void ModelInput::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.data_type)
}

// .inference.ModelInput.Format format = 3;
inline void ModelInput::clear_format() {
  format_ = 0;
}
inline ::inference::ModelInput_Format ModelInput::_internal_format() const {
  return static_cast< ::inference::ModelInput_Format >(format_);
}
inline ::inference::ModelInput_Format ModelInput::format() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.format)
  return _internal_format();
}
inline void ModelInput::_internal_set_format(::inference::ModelInput_Format value) {
  
  format_ = value;
}
inline void ModelInput::set_format(::inference::ModelInput_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.format)
}

// repeated int64 dims = 4;
inline int ModelInput::_internal_dims_size() const {
  return dims_.size();
}
inline int ModelInput::dims_size() const {
  return _internal_dims_size();
}
inline void ModelInput::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelInput::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelInput::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.dims)
  return _internal_dims(index);
}
inline void ModelInput::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.dims)
}
inline void ModelInput::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
}
inline void ModelInput::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelInput.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelInput::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelInput::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelInput.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelInput::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelInput::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelInput.dims)
  return _internal_mutable_dims();
}

// .inference.ModelTensorReshape reshape = 5;
inline bool ModelInput::_internal_has_reshape() const {
  return this != internal_default_instance() && reshape_ != nullptr;
}
inline bool ModelInput::has_reshape() const {
  return _internal_has_reshape();
}
inline void ModelInput::clear_reshape() {
  if (GetArena() == nullptr && reshape_ != nullptr) {
    delete reshape_;
  }
  reshape_ = nullptr;
}
inline const ::inference::ModelTensorReshape& ModelInput::_internal_reshape() const {
  const ::inference::ModelTensorReshape* p = reshape_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelTensorReshape&>(
      ::inference::_ModelTensorReshape_default_instance_);
}
inline const ::inference::ModelTensorReshape& ModelInput::reshape() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.reshape)
  return _internal_reshape();
}
inline void ModelInput::unsafe_arena_set_allocated_reshape(
    ::inference::ModelTensorReshape* reshape) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reshape_);
  }
  reshape_ = reshape;
  if (reshape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelInput.reshape)
}
inline ::inference::ModelTensorReshape* ModelInput::release_reshape() {
  
  ::inference::ModelTensorReshape* temp = reshape_;
  reshape_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelTensorReshape* ModelInput::unsafe_arena_release_reshape() {
  // @@protoc_insertion_point(field_release:inference.ModelInput.reshape)
  
  ::inference::ModelTensorReshape* temp = reshape_;
  reshape_ = nullptr;
  return temp;
}
inline ::inference::ModelTensorReshape* ModelInput::_internal_mutable_reshape() {
  
  if (reshape_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelTensorReshape>(GetArena());
    reshape_ = p;
  }
  return reshape_;
}
inline ::inference::ModelTensorReshape* ModelInput::mutable_reshape() {
  // @@protoc_insertion_point(field_mutable:inference.ModelInput.reshape)
  return _internal_mutable_reshape();
}
inline void ModelInput::set_allocated_reshape(::inference::ModelTensorReshape* reshape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reshape_;
  }
  if (reshape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(reshape);
    if (message_arena != submessage_arena) {
      reshape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshape, submessage_arena);
    }
    
  } else {
    
  }
  reshape_ = reshape;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelInput.reshape)
}

// bool is_shape_tensor = 6;
inline void ModelInput::clear_is_shape_tensor() {
  is_shape_tensor_ = false;
}
inline bool ModelInput::_internal_is_shape_tensor() const {
  return is_shape_tensor_;
}
inline bool ModelInput::is_shape_tensor() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.is_shape_tensor)
  return _internal_is_shape_tensor();
}
inline void ModelInput::_internal_set_is_shape_tensor(bool value) {
  
  is_shape_tensor_ = value;
}
inline void ModelInput::set_is_shape_tensor(bool value) {
  _internal_set_is_shape_tensor(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.is_shape_tensor)
}

// bool allow_ragged_batch = 7;
inline void ModelInput::clear_allow_ragged_batch() {
  allow_ragged_batch_ = false;
}
inline bool ModelInput::_internal_allow_ragged_batch() const {
  return allow_ragged_batch_;
}
inline bool ModelInput::allow_ragged_batch() const {
  // @@protoc_insertion_point(field_get:inference.ModelInput.allow_ragged_batch)
  return _internal_allow_ragged_batch();
}
inline void ModelInput::_internal_set_allow_ragged_batch(bool value) {
  
  allow_ragged_batch_ = value;
}
inline void ModelInput::set_allow_ragged_batch(bool value) {
  _internal_set_allow_ragged_batch(value);
  // @@protoc_insertion_point(field_set:inference.ModelInput.allow_ragged_batch)
}

// -------------------------------------------------------------------

// ModelOutput

// string name = 1;
inline void ModelOutput::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelOutput::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.name)
  return _internal_name();
}
inline void ModelOutput::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.name)
}
inline std::string* ModelOutput::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOutput.name)
  return _internal_mutable_name();
}
inline const std::string& ModelOutput::_internal_name() const {
  return name_.Get();
}
inline void ModelOutput::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelOutput::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelOutput.name)
}
inline void ModelOutput::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelOutput.name)
}
inline void ModelOutput::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelOutput.name)
}
inline std::string* ModelOutput::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelOutput::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelOutput.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelOutput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOutput.name)
}

// .inference.DataType data_type = 2;
inline void ModelOutput::clear_data_type() {
  data_type_ = 0;
}
inline ::inference::DataType ModelOutput::_internal_data_type() const {
  return static_cast< ::inference::DataType >(data_type_);
}
inline ::inference::DataType ModelOutput::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.data_type)
  return _internal_data_type();
}
inline void ModelOutput::_internal_set_data_type(::inference::DataType value) {
  
  data_type_ = value;
}
inline void ModelOutput::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.data_type)
}

// repeated int64 dims = 3;
inline int ModelOutput::_internal_dims_size() const {
  return dims_.size();
}
inline int ModelOutput::dims_size() const {
  return _internal_dims_size();
}
inline void ModelOutput::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelOutput::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelOutput::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.dims)
  return _internal_dims(index);
}
inline void ModelOutput::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.dims)
}
inline void ModelOutput::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
}
inline void ModelOutput::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelOutput.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelOutput::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelOutput::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelOutput.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelOutput::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelOutput::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOutput.dims)
  return _internal_mutable_dims();
}

// .inference.ModelTensorReshape reshape = 5;
inline bool ModelOutput::_internal_has_reshape() const {
  return this != internal_default_instance() && reshape_ != nullptr;
}
inline bool ModelOutput::has_reshape() const {
  return _internal_has_reshape();
}
inline void ModelOutput::clear_reshape() {
  if (GetArena() == nullptr && reshape_ != nullptr) {
    delete reshape_;
  }
  reshape_ = nullptr;
}
inline const ::inference::ModelTensorReshape& ModelOutput::_internal_reshape() const {
  const ::inference::ModelTensorReshape* p = reshape_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelTensorReshape&>(
      ::inference::_ModelTensorReshape_default_instance_);
}
inline const ::inference::ModelTensorReshape& ModelOutput::reshape() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.reshape)
  return _internal_reshape();
}
inline void ModelOutput::unsafe_arena_set_allocated_reshape(
    ::inference::ModelTensorReshape* reshape) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reshape_);
  }
  reshape_ = reshape;
  if (reshape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOutput.reshape)
}
inline ::inference::ModelTensorReshape* ModelOutput::release_reshape() {
  
  ::inference::ModelTensorReshape* temp = reshape_;
  reshape_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelTensorReshape* ModelOutput::unsafe_arena_release_reshape() {
  // @@protoc_insertion_point(field_release:inference.ModelOutput.reshape)
  
  ::inference::ModelTensorReshape* temp = reshape_;
  reshape_ = nullptr;
  return temp;
}
inline ::inference::ModelTensorReshape* ModelOutput::_internal_mutable_reshape() {
  
  if (reshape_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelTensorReshape>(GetArena());
    reshape_ = p;
  }
  return reshape_;
}
inline ::inference::ModelTensorReshape* ModelOutput::mutable_reshape() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOutput.reshape)
  return _internal_mutable_reshape();
}
inline void ModelOutput::set_allocated_reshape(::inference::ModelTensorReshape* reshape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reshape_;
  }
  if (reshape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(reshape);
    if (message_arena != submessage_arena) {
      reshape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reshape, submessage_arena);
    }
    
  } else {
    
  }
  reshape_ = reshape;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOutput.reshape)
}

// string label_filename = 4;
inline void ModelOutput::clear_label_filename() {
  label_filename_.ClearToEmpty();
}
inline const std::string& ModelOutput::label_filename() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.label_filename)
  return _internal_label_filename();
}
inline void ModelOutput::set_label_filename(const std::string& value) {
  _internal_set_label_filename(value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.label_filename)
}
inline std::string* ModelOutput::mutable_label_filename() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOutput.label_filename)
  return _internal_mutable_label_filename();
}
inline const std::string& ModelOutput::_internal_label_filename() const {
  return label_filename_.Get();
}
inline void ModelOutput::_internal_set_label_filename(const std::string& value) {
  
  label_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelOutput::set_label_filename(std::string&& value) {
  
  label_filename_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelOutput.label_filename)
}
inline void ModelOutput::set_label_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  label_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelOutput.label_filename)
}
inline void ModelOutput::set_label_filename(const char* value,
    size_t size) {
  
  label_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelOutput.label_filename)
}
inline std::string* ModelOutput::_internal_mutable_label_filename() {
  
  return label_filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelOutput::release_label_filename() {
  // @@protoc_insertion_point(field_release:inference.ModelOutput.label_filename)
  return label_filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelOutput::set_allocated_label_filename(std::string* label_filename) {
  if (label_filename != nullptr) {
    
  } else {
    
  }
  label_filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label_filename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOutput.label_filename)
}

// bool is_shape_tensor = 6;
inline void ModelOutput::clear_is_shape_tensor() {
  is_shape_tensor_ = false;
}
inline bool ModelOutput::_internal_is_shape_tensor() const {
  return is_shape_tensor_;
}
inline bool ModelOutput::is_shape_tensor() const {
  // @@protoc_insertion_point(field_get:inference.ModelOutput.is_shape_tensor)
  return _internal_is_shape_tensor();
}
inline void ModelOutput::_internal_set_is_shape_tensor(bool value) {
  
  is_shape_tensor_ = value;
}
inline void ModelOutput::set_is_shape_tensor(bool value) {
  _internal_set_is_shape_tensor(value);
  // @@protoc_insertion_point(field_set:inference.ModelOutput.is_shape_tensor)
}

// -------------------------------------------------------------------

// BatchInput

// .inference.BatchInput.Kind kind = 1;
inline void BatchInput::clear_kind() {
  kind_ = 0;
}
inline ::inference::BatchInput_Kind BatchInput::_internal_kind() const {
  return static_cast< ::inference::BatchInput_Kind >(kind_);
}
inline ::inference::BatchInput_Kind BatchInput::kind() const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.kind)
  return _internal_kind();
}
inline void BatchInput::_internal_set_kind(::inference::BatchInput_Kind value) {
  
  kind_ = value;
}
inline void BatchInput::set_kind(::inference::BatchInput_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.BatchInput.kind)
}

// repeated string target_name = 2;
inline int BatchInput::_internal_target_name_size() const {
  return target_name_.size();
}
inline int BatchInput::target_name_size() const {
  return _internal_target_name_size();
}
inline void BatchInput::clear_target_name() {
  target_name_.Clear();
}
inline std::string* BatchInput::add_target_name() {
  // @@protoc_insertion_point(field_add_mutable:inference.BatchInput.target_name)
  return _internal_add_target_name();
}
inline const std::string& BatchInput::_internal_target_name(int index) const {
  return target_name_.Get(index);
}
inline const std::string& BatchInput::target_name(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.target_name)
  return _internal_target_name(index);
}
inline std::string* BatchInput::mutable_target_name(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchInput.target_name)
  return target_name_.Mutable(index);
}
inline void BatchInput::set_target_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:inference.BatchInput.target_name)
  target_name_.Mutable(index)->assign(value);
}
inline void BatchInput::set_target_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:inference.BatchInput.target_name)
  target_name_.Mutable(index)->assign(std::move(value));
}
inline void BatchInput::set_target_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  target_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchInput.target_name)
}
inline void BatchInput::set_target_name(int index, const char* value, size_t size) {
  target_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchInput.target_name)
}
inline std::string* BatchInput::_internal_add_target_name() {
  return target_name_.Add();
}
inline void BatchInput::add_target_name(const std::string& value) {
  target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchInput.target_name)
}
inline void BatchInput::add_target_name(std::string&& value) {
  target_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchInput.target_name)
}
inline void BatchInput::add_target_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchInput.target_name)
}
inline void BatchInput::add_target_name(const char* value, size_t size) {
  target_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchInput.target_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchInput::target_name() const {
  // @@protoc_insertion_point(field_list:inference.BatchInput.target_name)
  return target_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchInput::mutable_target_name() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchInput.target_name)
  return &target_name_;
}

// .inference.DataType data_type = 3;
inline void BatchInput::clear_data_type() {
  data_type_ = 0;
}
inline ::inference::DataType BatchInput::_internal_data_type() const {
  return static_cast< ::inference::DataType >(data_type_);
}
inline ::inference::DataType BatchInput::data_type() const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.data_type)
  return _internal_data_type();
}
inline void BatchInput::_internal_set_data_type(::inference::DataType value) {
  
  data_type_ = value;
}
inline void BatchInput::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.BatchInput.data_type)
}

// repeated string source_input = 4;
inline int BatchInput::_internal_source_input_size() const {
  return source_input_.size();
}
inline int BatchInput::source_input_size() const {
  return _internal_source_input_size();
}
inline void BatchInput::clear_source_input() {
  source_input_.Clear();
}
inline std::string* BatchInput::add_source_input() {
  // @@protoc_insertion_point(field_add_mutable:inference.BatchInput.source_input)
  return _internal_add_source_input();
}
inline const std::string& BatchInput::_internal_source_input(int index) const {
  return source_input_.Get(index);
}
inline const std::string& BatchInput::source_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchInput.source_input)
  return _internal_source_input(index);
}
inline std::string* BatchInput::mutable_source_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchInput.source_input)
  return source_input_.Mutable(index);
}
inline void BatchInput::set_source_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:inference.BatchInput.source_input)
  source_input_.Mutable(index)->assign(value);
}
inline void BatchInput::set_source_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:inference.BatchInput.source_input)
  source_input_.Mutable(index)->assign(std::move(value));
}
inline void BatchInput::set_source_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  source_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchInput.source_input)
}
inline void BatchInput::set_source_input(int index, const char* value, size_t size) {
  source_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchInput.source_input)
}
inline std::string* BatchInput::_internal_add_source_input() {
  return source_input_.Add();
}
inline void BatchInput::add_source_input(const std::string& value) {
  source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchInput.source_input)
}
inline void BatchInput::add_source_input(std::string&& value) {
  source_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchInput.source_input)
}
inline void BatchInput::add_source_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchInput.source_input)
}
inline void BatchInput::add_source_input(const char* value, size_t size) {
  source_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchInput.source_input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchInput::source_input() const {
  // @@protoc_insertion_point(field_list:inference.BatchInput.source_input)
  return source_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchInput::mutable_source_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchInput.source_input)
  return &source_input_;
}

// -------------------------------------------------------------------

// BatchOutput

// repeated string target_name = 1;
inline int BatchOutput::_internal_target_name_size() const {
  return target_name_.size();
}
inline int BatchOutput::target_name_size() const {
  return _internal_target_name_size();
}
inline void BatchOutput::clear_target_name() {
  target_name_.Clear();
}
inline std::string* BatchOutput::add_target_name() {
  // @@protoc_insertion_point(field_add_mutable:inference.BatchOutput.target_name)
  return _internal_add_target_name();
}
inline const std::string& BatchOutput::_internal_target_name(int index) const {
  return target_name_.Get(index);
}
inline const std::string& BatchOutput::target_name(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchOutput.target_name)
  return _internal_target_name(index);
}
inline std::string* BatchOutput::mutable_target_name(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchOutput.target_name)
  return target_name_.Mutable(index);
}
inline void BatchOutput::set_target_name(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:inference.BatchOutput.target_name)
  target_name_.Mutable(index)->assign(value);
}
inline void BatchOutput::set_target_name(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:inference.BatchOutput.target_name)
  target_name_.Mutable(index)->assign(std::move(value));
}
inline void BatchOutput::set_target_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  target_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchOutput.target_name)
}
inline void BatchOutput::set_target_name(int index, const char* value, size_t size) {
  target_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchOutput.target_name)
}
inline std::string* BatchOutput::_internal_add_target_name() {
  return target_name_.Add();
}
inline void BatchOutput::add_target_name(const std::string& value) {
  target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchOutput.target_name)
}
inline void BatchOutput::add_target_name(std::string&& value) {
  target_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchOutput.target_name)
}
inline void BatchOutput::add_target_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  target_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchOutput.target_name)
}
inline void BatchOutput::add_target_name(const char* value, size_t size) {
  target_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchOutput.target_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchOutput::target_name() const {
  // @@protoc_insertion_point(field_list:inference.BatchOutput.target_name)
  return target_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchOutput::mutable_target_name() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchOutput.target_name)
  return &target_name_;
}

// .inference.BatchOutput.Kind kind = 2;
inline void BatchOutput::clear_kind() {
  kind_ = 0;
}
inline ::inference::BatchOutput_Kind BatchOutput::_internal_kind() const {
  return static_cast< ::inference::BatchOutput_Kind >(kind_);
}
inline ::inference::BatchOutput_Kind BatchOutput::kind() const {
  // @@protoc_insertion_point(field_get:inference.BatchOutput.kind)
  return _internal_kind();
}
inline void BatchOutput::_internal_set_kind(::inference::BatchOutput_Kind value) {
  
  kind_ = value;
}
inline void BatchOutput::set_kind(::inference::BatchOutput_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.BatchOutput.kind)
}

// repeated string source_input = 3;
inline int BatchOutput::_internal_source_input_size() const {
  return source_input_.size();
}
inline int BatchOutput::source_input_size() const {
  return _internal_source_input_size();
}
inline void BatchOutput::clear_source_input() {
  source_input_.Clear();
}
inline std::string* BatchOutput::add_source_input() {
  // @@protoc_insertion_point(field_add_mutable:inference.BatchOutput.source_input)
  return _internal_add_source_input();
}
inline const std::string& BatchOutput::_internal_source_input(int index) const {
  return source_input_.Get(index);
}
inline const std::string& BatchOutput::source_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.BatchOutput.source_input)
  return _internal_source_input(index);
}
inline std::string* BatchOutput::mutable_source_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.BatchOutput.source_input)
  return source_input_.Mutable(index);
}
inline void BatchOutput::set_source_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:inference.BatchOutput.source_input)
  source_input_.Mutable(index)->assign(value);
}
inline void BatchOutput::set_source_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:inference.BatchOutput.source_input)
  source_input_.Mutable(index)->assign(std::move(value));
}
inline void BatchOutput::set_source_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  source_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.BatchOutput.source_input)
}
inline void BatchOutput::set_source_input(int index, const char* value, size_t size) {
  source_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.BatchOutput.source_input)
}
inline std::string* BatchOutput::_internal_add_source_input() {
  return source_input_.Add();
}
inline void BatchOutput::add_source_input(const std::string& value) {
  source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.BatchOutput.source_input)
}
inline void BatchOutput::add_source_input(std::string&& value) {
  source_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.BatchOutput.source_input)
}
inline void BatchOutput::add_source_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  source_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.BatchOutput.source_input)
}
inline void BatchOutput::add_source_input(const char* value, size_t size) {
  source_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.BatchOutput.source_input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchOutput::source_input() const {
  // @@protoc_insertion_point(field_list:inference.BatchOutput.source_input)
  return source_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchOutput::mutable_source_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.BatchOutput.source_input)
  return &source_input_;
}

// -------------------------------------------------------------------

// ModelVersionPolicy_Latest

// uint32 num_versions = 1;
inline void ModelVersionPolicy_Latest::clear_num_versions() {
  num_versions_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelVersionPolicy_Latest::_internal_num_versions() const {
  return num_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelVersionPolicy_Latest::num_versions() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.Latest.num_versions)
  return _internal_num_versions();
}
inline void ModelVersionPolicy_Latest::_internal_set_num_versions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  num_versions_ = value;
}
inline void ModelVersionPolicy_Latest::set_num_versions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_versions(value);
  // @@protoc_insertion_point(field_set:inference.ModelVersionPolicy.Latest.num_versions)
}

// -------------------------------------------------------------------

// ModelVersionPolicy_All

// -------------------------------------------------------------------

// ModelVersionPolicy_Specific

// repeated int64 versions = 1;
inline int ModelVersionPolicy_Specific::_internal_versions_size() const {
  return versions_.size();
}
inline int ModelVersionPolicy_Specific::versions_size() const {
  return _internal_versions_size();
}
inline void ModelVersionPolicy_Specific::clear_versions() {
  versions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelVersionPolicy_Specific::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelVersionPolicy_Specific::versions(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.Specific.versions)
  return _internal_versions(index);
}
inline void ModelVersionPolicy_Specific::set_versions(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelVersionPolicy.Specific.versions)
}
inline void ModelVersionPolicy_Specific::_internal_add_versions(::PROTOBUF_NAMESPACE_ID::int64 value) {
  versions_.Add(value);
}
inline void ModelVersionPolicy_Specific::add_versions(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_versions(value);
  // @@protoc_insertion_point(field_add:inference.ModelVersionPolicy.Specific.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelVersionPolicy_Specific::_internal_versions() const {
  return versions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelVersionPolicy_Specific::versions() const {
  // @@protoc_insertion_point(field_list:inference.ModelVersionPolicy.Specific.versions)
  return _internal_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelVersionPolicy_Specific::_internal_mutable_versions() {
  return &versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelVersionPolicy_Specific::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelVersionPolicy.Specific.versions)
  return _internal_mutable_versions();
}

// -------------------------------------------------------------------

// ModelVersionPolicy

// .inference.ModelVersionPolicy.Latest latest = 1;
inline bool ModelVersionPolicy::_internal_has_latest() const {
  return policy_choice_case() == kLatest;
}
inline bool ModelVersionPolicy::has_latest() const {
  return _internal_has_latest();
}
inline void ModelVersionPolicy::set_has_latest() {
  _oneof_case_[0] = kLatest;
}
inline void ModelVersionPolicy::clear_latest() {
  if (_internal_has_latest()) {
    if (GetArena() == nullptr) {
      delete policy_choice_.latest_;
    }
    clear_has_policy_choice();
  }
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::release_latest() {
  // @@protoc_insertion_point(field_release:inference.ModelVersionPolicy.latest)
  if (_internal_has_latest()) {
    clear_has_policy_choice();
      ::inference::ModelVersionPolicy_Latest* temp = policy_choice_.latest_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    policy_choice_.latest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelVersionPolicy_Latest& ModelVersionPolicy::_internal_latest() const {
  return _internal_has_latest()
      ? *policy_choice_.latest_
      : reinterpret_cast< ::inference::ModelVersionPolicy_Latest&>(::inference::_ModelVersionPolicy_Latest_default_instance_);
}
inline const ::inference::ModelVersionPolicy_Latest& ModelVersionPolicy::latest() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.latest)
  return _internal_latest();
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::unsafe_arena_release_latest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelVersionPolicy.latest)
  if (_internal_has_latest()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_Latest* temp = policy_choice_.latest_;
    policy_choice_.latest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelVersionPolicy::unsafe_arena_set_allocated_latest(::inference::ModelVersionPolicy_Latest* latest) {
  clear_policy_choice();
  if (latest) {
    set_has_latest();
    policy_choice_.latest_ = latest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelVersionPolicy.latest)
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::_internal_mutable_latest() {
  if (!_internal_has_latest()) {
    clear_policy_choice();
    set_has_latest();
    policy_choice_.latest_ = CreateMaybeMessage< ::inference::ModelVersionPolicy_Latest >(GetArena());
  }
  return policy_choice_.latest_;
}
inline ::inference::ModelVersionPolicy_Latest* ModelVersionPolicy::mutable_latest() {
  // @@protoc_insertion_point(field_mutable:inference.ModelVersionPolicy.latest)
  return _internal_mutable_latest();
}

// .inference.ModelVersionPolicy.All all = 2;
inline bool ModelVersionPolicy::_internal_has_all() const {
  return policy_choice_case() == kAll;
}
inline bool ModelVersionPolicy::has_all() const {
  return _internal_has_all();
}
inline void ModelVersionPolicy::set_has_all() {
  _oneof_case_[0] = kAll;
}
inline void ModelVersionPolicy::clear_all() {
  if (_internal_has_all()) {
    if (GetArena() == nullptr) {
      delete policy_choice_.all_;
    }
    clear_has_policy_choice();
  }
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::release_all() {
  // @@protoc_insertion_point(field_release:inference.ModelVersionPolicy.all)
  if (_internal_has_all()) {
    clear_has_policy_choice();
      ::inference::ModelVersionPolicy_All* temp = policy_choice_.all_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    policy_choice_.all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelVersionPolicy_All& ModelVersionPolicy::_internal_all() const {
  return _internal_has_all()
      ? *policy_choice_.all_
      : reinterpret_cast< ::inference::ModelVersionPolicy_All&>(::inference::_ModelVersionPolicy_All_default_instance_);
}
inline const ::inference::ModelVersionPolicy_All& ModelVersionPolicy::all() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.all)
  return _internal_all();
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::unsafe_arena_release_all() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelVersionPolicy.all)
  if (_internal_has_all()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_All* temp = policy_choice_.all_;
    policy_choice_.all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelVersionPolicy::unsafe_arena_set_allocated_all(::inference::ModelVersionPolicy_All* all) {
  clear_policy_choice();
  if (all) {
    set_has_all();
    policy_choice_.all_ = all;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelVersionPolicy.all)
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::_internal_mutable_all() {
  if (!_internal_has_all()) {
    clear_policy_choice();
    set_has_all();
    policy_choice_.all_ = CreateMaybeMessage< ::inference::ModelVersionPolicy_All >(GetArena());
  }
  return policy_choice_.all_;
}
inline ::inference::ModelVersionPolicy_All* ModelVersionPolicy::mutable_all() {
  // @@protoc_insertion_point(field_mutable:inference.ModelVersionPolicy.all)
  return _internal_mutable_all();
}

// .inference.ModelVersionPolicy.Specific specific = 3;
inline bool ModelVersionPolicy::_internal_has_specific() const {
  return policy_choice_case() == kSpecific;
}
inline bool ModelVersionPolicy::has_specific() const {
  return _internal_has_specific();
}
inline void ModelVersionPolicy::set_has_specific() {
  _oneof_case_[0] = kSpecific;
}
inline void ModelVersionPolicy::clear_specific() {
  if (_internal_has_specific()) {
    if (GetArena() == nullptr) {
      delete policy_choice_.specific_;
    }
    clear_has_policy_choice();
  }
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::release_specific() {
  // @@protoc_insertion_point(field_release:inference.ModelVersionPolicy.specific)
  if (_internal_has_specific()) {
    clear_has_policy_choice();
      ::inference::ModelVersionPolicy_Specific* temp = policy_choice_.specific_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    policy_choice_.specific_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelVersionPolicy_Specific& ModelVersionPolicy::_internal_specific() const {
  return _internal_has_specific()
      ? *policy_choice_.specific_
      : reinterpret_cast< ::inference::ModelVersionPolicy_Specific&>(::inference::_ModelVersionPolicy_Specific_default_instance_);
}
inline const ::inference::ModelVersionPolicy_Specific& ModelVersionPolicy::specific() const {
  // @@protoc_insertion_point(field_get:inference.ModelVersionPolicy.specific)
  return _internal_specific();
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::unsafe_arena_release_specific() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelVersionPolicy.specific)
  if (_internal_has_specific()) {
    clear_has_policy_choice();
    ::inference::ModelVersionPolicy_Specific* temp = policy_choice_.specific_;
    policy_choice_.specific_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelVersionPolicy::unsafe_arena_set_allocated_specific(::inference::ModelVersionPolicy_Specific* specific) {
  clear_policy_choice();
  if (specific) {
    set_has_specific();
    policy_choice_.specific_ = specific;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelVersionPolicy.specific)
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::_internal_mutable_specific() {
  if (!_internal_has_specific()) {
    clear_policy_choice();
    set_has_specific();
    policy_choice_.specific_ = CreateMaybeMessage< ::inference::ModelVersionPolicy_Specific >(GetArena());
  }
  return policy_choice_.specific_;
}
inline ::inference::ModelVersionPolicy_Specific* ModelVersionPolicy::mutable_specific() {
  // @@protoc_insertion_point(field_mutable:inference.ModelVersionPolicy.specific)
  return _internal_mutable_specific();
}

inline bool ModelVersionPolicy::has_policy_choice() const {
  return policy_choice_case() != POLICY_CHOICE_NOT_SET;
}
inline void ModelVersionPolicy::clear_has_policy_choice() {
  _oneof_case_[0] = POLICY_CHOICE_NOT_SET;
}
inline ModelVersionPolicy::PolicyChoiceCase ModelVersionPolicy::policy_choice_case() const {
  return ModelVersionPolicy::PolicyChoiceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ModelOptimizationPolicy_Graph

// int32 level = 1;
inline void ModelOptimizationPolicy_Graph::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelOptimizationPolicy_Graph::_internal_level() const {
  return level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelOptimizationPolicy_Graph::level() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Graph.level)
  return _internal_level();
}
inline void ModelOptimizationPolicy_Graph::_internal_set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
}
inline void ModelOptimizationPolicy_Graph::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Graph.level)
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda_GraphSpec_Shape

// repeated int64 dim = 1;
inline int ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_dim_size() const {
  return dim_.size();
}
inline int ModelOptimizationPolicy_Cuda_GraphSpec_Shape::dim_size() const {
  return _internal_dim_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::clear_dim() {
  dim_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_dim(int index) const {
  return dim_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelOptimizationPolicy_Cuda_GraphSpec_Shape::dim(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
  return _internal_dim(index);
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::set_dim(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dim_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_add_dim(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dim_.Add(value);
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_Shape::add_dim(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dim(value);
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_dim() const {
  return dim_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::dim() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
  return _internal_dim();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::_internal_mutable_dim() {
  return &dim_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelOptimizationPolicy_Cuda_GraphSpec_Shape::mutable_dim() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape.dim)
  return _internal_mutable_dim();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound

// int32 batch_size = 1;
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::clear_batch_size() {
  batch_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.batch_size)
  return _internal_batch_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  batch_size_ = value;
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.batch_size)
}

// map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
inline int ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_input_size() const {
  return input_.size();
}
inline int ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::input_size() const {
  return _internal_input_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::clear_input() {
  input_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_input() const {
  return input_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::input() const {
  // @@protoc_insertion_point(field_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.input)
  return _internal_input();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::_internal_mutable_input() {
  return input_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound::mutable_input() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound.input)
  return _internal_mutable_input();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda_GraphSpec

// int32 batch_size = 1;
inline void ModelOptimizationPolicy_Cuda_GraphSpec::clear_batch_size() {
  batch_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelOptimizationPolicy_Cuda_GraphSpec::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelOptimizationPolicy_Cuda_GraphSpec::batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.batch_size)
  return _internal_batch_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  batch_size_ = value;
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.GraphSpec.batch_size)
}

// map<string, .inference.ModelOptimizationPolicy.Cuda.GraphSpec.Shape> input = 2;
inline int ModelOptimizationPolicy_Cuda_GraphSpec::_internal_input_size() const {
  return input_.size();
}
inline int ModelOptimizationPolicy_Cuda_GraphSpec::input_size() const {
  return _internal_input_size();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::clear_input() {
  input_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec::_internal_input() const {
  return input_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >&
ModelOptimizationPolicy_Cuda_GraphSpec::input() const {
  // @@protoc_insertion_point(field_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.input)
  return _internal_input();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec::_internal_mutable_input() {
  return input_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_Shape >*
ModelOptimizationPolicy_Cuda_GraphSpec::mutable_input() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelOptimizationPolicy.Cuda.GraphSpec.input)
  return _internal_mutable_input();
}

// .inference.ModelOptimizationPolicy.Cuda.GraphSpec.LowerBound graph_lower_bound = 3;
inline bool ModelOptimizationPolicy_Cuda_GraphSpec::_internal_has_graph_lower_bound() const {
  return this != internal_default_instance() && graph_lower_bound_ != nullptr;
}
inline bool ModelOptimizationPolicy_Cuda_GraphSpec::has_graph_lower_bound() const {
  return _internal_has_graph_lower_bound();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::clear_graph_lower_bound() {
  if (GetArena() == nullptr && graph_lower_bound_ != nullptr) {
    delete graph_lower_bound_;
  }
  graph_lower_bound_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& ModelOptimizationPolicy_Cuda_GraphSpec::_internal_graph_lower_bound() const {
  const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* p = graph_lower_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound&>(
      ::inference::_ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound& ModelOptimizationPolicy_Cuda_GraphSpec::graph_lower_bound() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
  return _internal_graph_lower_bound();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::unsafe_arena_set_allocated_graph_lower_bound(
    ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_lower_bound_);
  }
  graph_lower_bound_ = graph_lower_bound;
  if (graph_lower_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::release_graph_lower_bound() {
  
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* temp = graph_lower_bound_;
  graph_lower_bound_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::unsafe_arena_release_graph_lower_bound() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
  
  ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* temp = graph_lower_bound_;
  graph_lower_bound_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::_internal_mutable_graph_lower_bound() {
  
  if (graph_lower_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound>(GetArena());
    graph_lower_bound_ = p;
  }
  return graph_lower_bound_;
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* ModelOptimizationPolicy_Cuda_GraphSpec::mutable_graph_lower_bound() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
  return _internal_mutable_graph_lower_bound();
}
inline void ModelOptimizationPolicy_Cuda_GraphSpec::set_allocated_graph_lower_bound(::inference::ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound* graph_lower_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete graph_lower_bound_;
  }
  if (graph_lower_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(graph_lower_bound);
    if (message_arena != submessage_arena) {
      graph_lower_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph_lower_bound, submessage_arena);
    }
    
  } else {
    
  }
  graph_lower_bound_ = graph_lower_bound;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.Cuda.GraphSpec.graph_lower_bound)
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_Cuda

// bool graphs = 1;
inline void ModelOptimizationPolicy_Cuda::clear_graphs() {
  graphs_ = false;
}
inline bool ModelOptimizationPolicy_Cuda::_internal_graphs() const {
  return graphs_;
}
inline bool ModelOptimizationPolicy_Cuda::graphs() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.graphs)
  return _internal_graphs();
}
inline void ModelOptimizationPolicy_Cuda::_internal_set_graphs(bool value) {
  
  graphs_ = value;
}
inline void ModelOptimizationPolicy_Cuda::set_graphs(bool value) {
  _internal_set_graphs(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.graphs)
}

// bool busy_wait_events = 2;
inline void ModelOptimizationPolicy_Cuda::clear_busy_wait_events() {
  busy_wait_events_ = false;
}
inline bool ModelOptimizationPolicy_Cuda::_internal_busy_wait_events() const {
  return busy_wait_events_;
}
inline bool ModelOptimizationPolicy_Cuda::busy_wait_events() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.busy_wait_events)
  return _internal_busy_wait_events();
}
inline void ModelOptimizationPolicy_Cuda::_internal_set_busy_wait_events(bool value) {
  
  busy_wait_events_ = value;
}
inline void ModelOptimizationPolicy_Cuda::set_busy_wait_events(bool value) {
  _internal_set_busy_wait_events(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.Cuda.busy_wait_events)
}

// repeated .inference.ModelOptimizationPolicy.Cuda.GraphSpec graph_spec = 3;
inline int ModelOptimizationPolicy_Cuda::_internal_graph_spec_size() const {
  return graph_spec_.size();
}
inline int ModelOptimizationPolicy_Cuda::graph_spec_size() const {
  return _internal_graph_spec_size();
}
inline void ModelOptimizationPolicy_Cuda::clear_graph_spec() {
  graph_spec_.Clear();
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* ModelOptimizationPolicy_Cuda::mutable_graph_spec(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return graph_spec_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >*
ModelOptimizationPolicy_Cuda::mutable_graph_spec() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return &graph_spec_;
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& ModelOptimizationPolicy_Cuda::_internal_graph_spec(int index) const {
  return graph_spec_.Get(index);
}
inline const ::inference::ModelOptimizationPolicy_Cuda_GraphSpec& ModelOptimizationPolicy_Cuda::graph_spec(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return _internal_graph_spec(index);
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* ModelOptimizationPolicy_Cuda::_internal_add_graph_spec() {
  return graph_spec_.Add();
}
inline ::inference::ModelOptimizationPolicy_Cuda_GraphSpec* ModelOptimizationPolicy_Cuda::add_graph_spec() {
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return _internal_add_graph_spec();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_Cuda_GraphSpec >&
ModelOptimizationPolicy_Cuda::graph_spec() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.Cuda.graph_spec)
  return graph_spec_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelOptimizationPolicy_ExecutionAccelerators_Accelerator

// string name = 1;
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
  return _internal_name();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
}
inline std::string* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
  return _internal_mutable_name();
}
inline const std::string& ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_name() const {
  return name_.Get();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
}
inline std::string* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.name)
}

// map<string, string> parameters = 2;
inline int ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelOptimizationPolicy_ExecutionAccelerators_Accelerator::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_ExecutionAccelerators

// repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator gpu_execution_accelerator = 1;
inline int ModelOptimizationPolicy_ExecutionAccelerators::_internal_gpu_execution_accelerator_size() const {
  return gpu_execution_accelerator_.size();
}
inline int ModelOptimizationPolicy_ExecutionAccelerators::gpu_execution_accelerator_size() const {
  return _internal_gpu_execution_accelerator_size();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators::clear_gpu_execution_accelerator() {
  gpu_execution_accelerator_.Clear();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::mutable_gpu_execution_accelerator(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return gpu_execution_accelerator_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
ModelOptimizationPolicy_ExecutionAccelerators::mutable_gpu_execution_accelerator() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return &gpu_execution_accelerator_;
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::_internal_gpu_execution_accelerator(int index) const {
  return gpu_execution_accelerator_.Get(index);
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::gpu_execution_accelerator(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return _internal_gpu_execution_accelerator(index);
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::_internal_add_gpu_execution_accelerator() {
  return gpu_execution_accelerator_.Add();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::add_gpu_execution_accelerator() {
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return _internal_add_gpu_execution_accelerator();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
ModelOptimizationPolicy_ExecutionAccelerators::gpu_execution_accelerator() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.gpu_execution_accelerator)
  return gpu_execution_accelerator_;
}

// repeated .inference.ModelOptimizationPolicy.ExecutionAccelerators.Accelerator cpu_execution_accelerator = 2;
inline int ModelOptimizationPolicy_ExecutionAccelerators::_internal_cpu_execution_accelerator_size() const {
  return cpu_execution_accelerator_.size();
}
inline int ModelOptimizationPolicy_ExecutionAccelerators::cpu_execution_accelerator_size() const {
  return _internal_cpu_execution_accelerator_size();
}
inline void ModelOptimizationPolicy_ExecutionAccelerators::clear_cpu_execution_accelerator() {
  cpu_execution_accelerator_.Clear();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::mutable_cpu_execution_accelerator(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return cpu_execution_accelerator_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >*
ModelOptimizationPolicy_ExecutionAccelerators::mutable_cpu_execution_accelerator() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return &cpu_execution_accelerator_;
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::_internal_cpu_execution_accelerator(int index) const {
  return cpu_execution_accelerator_.Get(index);
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator& ModelOptimizationPolicy_ExecutionAccelerators::cpu_execution_accelerator(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return _internal_cpu_execution_accelerator(index);
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::_internal_add_cpu_execution_accelerator() {
  return cpu_execution_accelerator_.Add();
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator* ModelOptimizationPolicy_ExecutionAccelerators::add_cpu_execution_accelerator() {
  // @@protoc_insertion_point(field_add:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return _internal_add_cpu_execution_accelerator();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOptimizationPolicy_ExecutionAccelerators_Accelerator >&
ModelOptimizationPolicy_ExecutionAccelerators::cpu_execution_accelerator() const {
  // @@protoc_insertion_point(field_list:inference.ModelOptimizationPolicy.ExecutionAccelerators.cpu_execution_accelerator)
  return cpu_execution_accelerator_;
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy_PinnedMemoryBuffer

// bool enable = 1;
inline void ModelOptimizationPolicy_PinnedMemoryBuffer::clear_enable() {
  enable_ = false;
}
inline bool ModelOptimizationPolicy_PinnedMemoryBuffer::_internal_enable() const {
  return enable_;
}
inline bool ModelOptimizationPolicy_PinnedMemoryBuffer::enable() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.PinnedMemoryBuffer.enable)
  return _internal_enable();
}
inline void ModelOptimizationPolicy_PinnedMemoryBuffer::_internal_set_enable(bool value) {
  
  enable_ = value;
}
inline void ModelOptimizationPolicy_PinnedMemoryBuffer::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.PinnedMemoryBuffer.enable)
}

// -------------------------------------------------------------------

// ModelOptimizationPolicy

// .inference.ModelOptimizationPolicy.Graph graph = 1;
inline bool ModelOptimizationPolicy::_internal_has_graph() const {
  return this != internal_default_instance() && graph_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_graph() const {
  return _internal_has_graph();
}
inline void ModelOptimizationPolicy::clear_graph() {
  if (GetArena() == nullptr && graph_ != nullptr) {
    delete graph_;
  }
  graph_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_Graph& ModelOptimizationPolicy::_internal_graph() const {
  const ::inference::ModelOptimizationPolicy_Graph* p = graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_Graph&>(
      ::inference::_ModelOptimizationPolicy_Graph_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_Graph& ModelOptimizationPolicy::graph() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.graph)
  return _internal_graph();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_graph(
    ::inference::ModelOptimizationPolicy_Graph* graph) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_);
  }
  graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.graph)
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::release_graph() {
  
  ::inference::ModelOptimizationPolicy_Graph* temp = graph_;
  graph_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.graph)
  
  ::inference::ModelOptimizationPolicy_Graph* temp = graph_;
  graph_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::_internal_mutable_graph() {
  
  if (graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_Graph>(GetArena());
    graph_ = p;
  }
  return graph_;
}
inline ::inference::ModelOptimizationPolicy_Graph* ModelOptimizationPolicy::mutable_graph() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.graph)
  return _internal_mutable_graph();
}
inline void ModelOptimizationPolicy::set_allocated_graph(::inference::ModelOptimizationPolicy_Graph* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete graph_;
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(graph);
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.graph)
}

// .inference.ModelOptimizationPolicy.ModelPriority priority = 2;
inline void ModelOptimizationPolicy::clear_priority() {
  priority_ = 0;
}
inline ::inference::ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::_internal_priority() const {
  return static_cast< ::inference::ModelOptimizationPolicy_ModelPriority >(priority_);
}
inline ::inference::ModelOptimizationPolicy_ModelPriority ModelOptimizationPolicy::priority() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.priority)
  return _internal_priority();
}
inline void ModelOptimizationPolicy::_internal_set_priority(::inference::ModelOptimizationPolicy_ModelPriority value) {
  
  priority_ = value;
}
inline void ModelOptimizationPolicy::set_priority(::inference::ModelOptimizationPolicy_ModelPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:inference.ModelOptimizationPolicy.priority)
}

// .inference.ModelOptimizationPolicy.Cuda cuda = 3;
inline bool ModelOptimizationPolicy::_internal_has_cuda() const {
  return this != internal_default_instance() && cuda_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_cuda() const {
  return _internal_has_cuda();
}
inline void ModelOptimizationPolicy::clear_cuda() {
  if (GetArena() == nullptr && cuda_ != nullptr) {
    delete cuda_;
  }
  cuda_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_Cuda& ModelOptimizationPolicy::_internal_cuda() const {
  const ::inference::ModelOptimizationPolicy_Cuda* p = cuda_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_Cuda&>(
      ::inference::_ModelOptimizationPolicy_Cuda_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_Cuda& ModelOptimizationPolicy::cuda() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.cuda)
  return _internal_cuda();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_cuda(
    ::inference::ModelOptimizationPolicy_Cuda* cuda) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cuda_);
  }
  cuda_ = cuda;
  if (cuda) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.cuda)
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::release_cuda() {
  
  ::inference::ModelOptimizationPolicy_Cuda* temp = cuda_;
  cuda_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::unsafe_arena_release_cuda() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.cuda)
  
  ::inference::ModelOptimizationPolicy_Cuda* temp = cuda_;
  cuda_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::_internal_mutable_cuda() {
  
  if (cuda_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_Cuda>(GetArena());
    cuda_ = p;
  }
  return cuda_;
}
inline ::inference::ModelOptimizationPolicy_Cuda* ModelOptimizationPolicy::mutable_cuda() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.cuda)
  return _internal_mutable_cuda();
}
inline void ModelOptimizationPolicy::set_allocated_cuda(::inference::ModelOptimizationPolicy_Cuda* cuda) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cuda_;
  }
  if (cuda) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cuda);
    if (message_arena != submessage_arena) {
      cuda = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cuda, submessage_arena);
    }
    
  } else {
    
  }
  cuda_ = cuda;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.cuda)
}

// .inference.ModelOptimizationPolicy.ExecutionAccelerators execution_accelerators = 4;
inline bool ModelOptimizationPolicy::_internal_has_execution_accelerators() const {
  return this != internal_default_instance() && execution_accelerators_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_execution_accelerators() const {
  return _internal_has_execution_accelerators();
}
inline void ModelOptimizationPolicy::clear_execution_accelerators() {
  if (GetArena() == nullptr && execution_accelerators_ != nullptr) {
    delete execution_accelerators_;
  }
  execution_accelerators_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& ModelOptimizationPolicy::_internal_execution_accelerators() const {
  const ::inference::ModelOptimizationPolicy_ExecutionAccelerators* p = execution_accelerators_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_ExecutionAccelerators&>(
      ::inference::_ModelOptimizationPolicy_ExecutionAccelerators_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_ExecutionAccelerators& ModelOptimizationPolicy::execution_accelerators() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.execution_accelerators)
  return _internal_execution_accelerators();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_execution_accelerators(
    ::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_accelerators_);
  }
  execution_accelerators_ = execution_accelerators;
  if (execution_accelerators) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.execution_accelerators)
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::release_execution_accelerators() {
  
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* temp = execution_accelerators_;
  execution_accelerators_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::unsafe_arena_release_execution_accelerators() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.execution_accelerators)
  
  ::inference::ModelOptimizationPolicy_ExecutionAccelerators* temp = execution_accelerators_;
  execution_accelerators_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::_internal_mutable_execution_accelerators() {
  
  if (execution_accelerators_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_ExecutionAccelerators>(GetArena());
    execution_accelerators_ = p;
  }
  return execution_accelerators_;
}
inline ::inference::ModelOptimizationPolicy_ExecutionAccelerators* ModelOptimizationPolicy::mutable_execution_accelerators() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.execution_accelerators)
  return _internal_mutable_execution_accelerators();
}
inline void ModelOptimizationPolicy::set_allocated_execution_accelerators(::inference::ModelOptimizationPolicy_ExecutionAccelerators* execution_accelerators) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete execution_accelerators_;
  }
  if (execution_accelerators) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(execution_accelerators);
    if (message_arena != submessage_arena) {
      execution_accelerators = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_accelerators, submessage_arena);
    }
    
  } else {
    
  }
  execution_accelerators_ = execution_accelerators;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.execution_accelerators)
}

// .inference.ModelOptimizationPolicy.PinnedMemoryBuffer input_pinned_memory = 5;
inline bool ModelOptimizationPolicy::_internal_has_input_pinned_memory() const {
  return this != internal_default_instance() && input_pinned_memory_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_input_pinned_memory() const {
  return _internal_has_input_pinned_memory();
}
inline void ModelOptimizationPolicy::clear_input_pinned_memory() {
  if (GetArena() == nullptr && input_pinned_memory_ != nullptr) {
    delete input_pinned_memory_;
  }
  input_pinned_memory_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::_internal_input_pinned_memory() const {
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* p = input_pinned_memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&>(
      ::inference::_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::input_pinned_memory() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.input_pinned_memory)
  return _internal_input_pinned_memory();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_input_pinned_memory(
    ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_pinned_memory_);
  }
  input_pinned_memory_ = input_pinned_memory;
  if (input_pinned_memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.input_pinned_memory)
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::release_input_pinned_memory() {
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = input_pinned_memory_;
  input_pinned_memory_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::unsafe_arena_release_input_pinned_memory() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.input_pinned_memory)
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = input_pinned_memory_;
  input_pinned_memory_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::_internal_mutable_input_pinned_memory() {
  
  if (input_pinned_memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_PinnedMemoryBuffer>(GetArena());
    input_pinned_memory_ = p;
  }
  return input_pinned_memory_;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::mutable_input_pinned_memory() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.input_pinned_memory)
  return _internal_mutable_input_pinned_memory();
}
inline void ModelOptimizationPolicy::set_allocated_input_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* input_pinned_memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete input_pinned_memory_;
  }
  if (input_pinned_memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(input_pinned_memory);
    if (message_arena != submessage_arena) {
      input_pinned_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_pinned_memory, submessage_arena);
    }
    
  } else {
    
  }
  input_pinned_memory_ = input_pinned_memory;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.input_pinned_memory)
}

// .inference.ModelOptimizationPolicy.PinnedMemoryBuffer output_pinned_memory = 6;
inline bool ModelOptimizationPolicy::_internal_has_output_pinned_memory() const {
  return this != internal_default_instance() && output_pinned_memory_ != nullptr;
}
inline bool ModelOptimizationPolicy::has_output_pinned_memory() const {
  return _internal_has_output_pinned_memory();
}
inline void ModelOptimizationPolicy::clear_output_pinned_memory() {
  if (GetArena() == nullptr && output_pinned_memory_ != nullptr) {
    delete output_pinned_memory_;
  }
  output_pinned_memory_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::_internal_output_pinned_memory() const {
  const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* p = output_pinned_memory_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer&>(
      ::inference::_ModelOptimizationPolicy_PinnedMemoryBuffer_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer& ModelOptimizationPolicy::output_pinned_memory() const {
  // @@protoc_insertion_point(field_get:inference.ModelOptimizationPolicy.output_pinned_memory)
  return _internal_output_pinned_memory();
}
inline void ModelOptimizationPolicy::unsafe_arena_set_allocated_output_pinned_memory(
    ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_pinned_memory_);
  }
  output_pinned_memory_ = output_pinned_memory;
  if (output_pinned_memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelOptimizationPolicy.output_pinned_memory)
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::release_output_pinned_memory() {
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = output_pinned_memory_;
  output_pinned_memory_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::unsafe_arena_release_output_pinned_memory() {
  // @@protoc_insertion_point(field_release:inference.ModelOptimizationPolicy.output_pinned_memory)
  
  ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* temp = output_pinned_memory_;
  output_pinned_memory_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::_internal_mutable_output_pinned_memory() {
  
  if (output_pinned_memory_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy_PinnedMemoryBuffer>(GetArena());
    output_pinned_memory_ = p;
  }
  return output_pinned_memory_;
}
inline ::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* ModelOptimizationPolicy::mutable_output_pinned_memory() {
  // @@protoc_insertion_point(field_mutable:inference.ModelOptimizationPolicy.output_pinned_memory)
  return _internal_mutable_output_pinned_memory();
}
inline void ModelOptimizationPolicy::set_allocated_output_pinned_memory(::inference::ModelOptimizationPolicy_PinnedMemoryBuffer* output_pinned_memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete output_pinned_memory_;
  }
  if (output_pinned_memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(output_pinned_memory);
    if (message_arena != submessage_arena) {
      output_pinned_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_pinned_memory, submessage_arena);
    }
    
  } else {
    
  }
  output_pinned_memory_ = output_pinned_memory;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelOptimizationPolicy.output_pinned_memory)
}

// -------------------------------------------------------------------

// ModelQueuePolicy

// .inference.ModelQueuePolicy.TimeoutAction timeout_action = 1;
inline void ModelQueuePolicy::clear_timeout_action() {
  timeout_action_ = 0;
}
inline ::inference::ModelQueuePolicy_TimeoutAction ModelQueuePolicy::_internal_timeout_action() const {
  return static_cast< ::inference::ModelQueuePolicy_TimeoutAction >(timeout_action_);
}
inline ::inference::ModelQueuePolicy_TimeoutAction ModelQueuePolicy::timeout_action() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.timeout_action)
  return _internal_timeout_action();
}
inline void ModelQueuePolicy::_internal_set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value) {
  
  timeout_action_ = value;
}
inline void ModelQueuePolicy::set_timeout_action(::inference::ModelQueuePolicy_TimeoutAction value) {
  _internal_set_timeout_action(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.timeout_action)
}

// uint64 default_timeout_microseconds = 2;
inline void ModelQueuePolicy::clear_default_timeout_microseconds() {
  default_timeout_microseconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelQueuePolicy::_internal_default_timeout_microseconds() const {
  return default_timeout_microseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelQueuePolicy::default_timeout_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.default_timeout_microseconds)
  return _internal_default_timeout_microseconds();
}
inline void ModelQueuePolicy::_internal_set_default_timeout_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  default_timeout_microseconds_ = value;
}
inline void ModelQueuePolicy::set_default_timeout_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_default_timeout_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.default_timeout_microseconds)
}

// bool allow_timeout_override = 3;
inline void ModelQueuePolicy::clear_allow_timeout_override() {
  allow_timeout_override_ = false;
}
inline bool ModelQueuePolicy::_internal_allow_timeout_override() const {
  return allow_timeout_override_;
}
inline bool ModelQueuePolicy::allow_timeout_override() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.allow_timeout_override)
  return _internal_allow_timeout_override();
}
inline void ModelQueuePolicy::_internal_set_allow_timeout_override(bool value) {
  
  allow_timeout_override_ = value;
}
inline void ModelQueuePolicy::set_allow_timeout_override(bool value) {
  _internal_set_allow_timeout_override(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.allow_timeout_override)
}

// uint32 max_queue_size = 4;
inline void ModelQueuePolicy::clear_max_queue_size() {
  max_queue_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelQueuePolicy::_internal_max_queue_size() const {
  return max_queue_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelQueuePolicy::max_queue_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelQueuePolicy.max_queue_size)
  return _internal_max_queue_size();
}
inline void ModelQueuePolicy::_internal_set_max_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  max_queue_size_ = value;
}
inline void ModelQueuePolicy::set_max_queue_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_queue_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelQueuePolicy.max_queue_size)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelDynamicBatching

// repeated int32 preferred_batch_size = 1;
inline int ModelDynamicBatching::_internal_preferred_batch_size_size() const {
  return preferred_batch_size_.size();
}
inline int ModelDynamicBatching::preferred_batch_size_size() const {
  return _internal_preferred_batch_size_size();
}
inline void ModelDynamicBatching::clear_preferred_batch_size() {
  preferred_batch_size_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelDynamicBatching::_internal_preferred_batch_size(int index) const {
  return preferred_batch_size_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelDynamicBatching::preferred_batch_size(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.preferred_batch_size)
  return _internal_preferred_batch_size(index);
}
inline void ModelDynamicBatching::set_preferred_batch_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  preferred_batch_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.preferred_batch_size)
}
inline void ModelDynamicBatching::_internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  preferred_batch_size_.Add(value);
}
inline void ModelDynamicBatching::add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_preferred_batch_size(value);
  // @@protoc_insertion_point(field_add:inference.ModelDynamicBatching.preferred_batch_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelDynamicBatching::_internal_preferred_batch_size() const {
  return preferred_batch_size_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelDynamicBatching::preferred_batch_size() const {
  // @@protoc_insertion_point(field_list:inference.ModelDynamicBatching.preferred_batch_size)
  return _internal_preferred_batch_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelDynamicBatching::_internal_mutable_preferred_batch_size() {
  return &preferred_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelDynamicBatching::mutable_preferred_batch_size() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelDynamicBatching.preferred_batch_size)
  return _internal_mutable_preferred_batch_size();
}

// uint64 max_queue_delay_microseconds = 2;
inline void ModelDynamicBatching::clear_max_queue_delay_microseconds() {
  max_queue_delay_microseconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelDynamicBatching::_internal_max_queue_delay_microseconds() const {
  return max_queue_delay_microseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelDynamicBatching::max_queue_delay_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.max_queue_delay_microseconds)
  return _internal_max_queue_delay_microseconds();
}
inline void ModelDynamicBatching::_internal_set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_queue_delay_microseconds_ = value;
}
inline void ModelDynamicBatching::set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_queue_delay_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.max_queue_delay_microseconds)
}

// bool preserve_ordering = 3;
inline void ModelDynamicBatching::clear_preserve_ordering() {
  preserve_ordering_ = false;
}
inline bool ModelDynamicBatching::_internal_preserve_ordering() const {
  return preserve_ordering_;
}
inline bool ModelDynamicBatching::preserve_ordering() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.preserve_ordering)
  return _internal_preserve_ordering();
}
inline void ModelDynamicBatching::_internal_set_preserve_ordering(bool value) {
  
  preserve_ordering_ = value;
}
inline void ModelDynamicBatching::set_preserve_ordering(bool value) {
  _internal_set_preserve_ordering(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.preserve_ordering)
}

// uint32 priority_levels = 4;
inline void ModelDynamicBatching::clear_priority_levels() {
  priority_levels_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelDynamicBatching::_internal_priority_levels() const {
  return priority_levels_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelDynamicBatching::priority_levels() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.priority_levels)
  return _internal_priority_levels();
}
inline void ModelDynamicBatching::_internal_set_priority_levels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  priority_levels_ = value;
}
inline void ModelDynamicBatching::set_priority_levels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_priority_levels(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.priority_levels)
}

// uint32 default_priority_level = 5;
inline void ModelDynamicBatching::clear_default_priority_level() {
  default_priority_level_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelDynamicBatching::_internal_default_priority_level() const {
  return default_priority_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelDynamicBatching::default_priority_level() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.default_priority_level)
  return _internal_default_priority_level();
}
inline void ModelDynamicBatching::_internal_set_default_priority_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  default_priority_level_ = value;
}
inline void ModelDynamicBatching::set_default_priority_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_default_priority_level(value);
  // @@protoc_insertion_point(field_set:inference.ModelDynamicBatching.default_priority_level)
}

// .inference.ModelQueuePolicy default_queue_policy = 6;
inline bool ModelDynamicBatching::_internal_has_default_queue_policy() const {
  return this != internal_default_instance() && default_queue_policy_ != nullptr;
}
inline bool ModelDynamicBatching::has_default_queue_policy() const {
  return _internal_has_default_queue_policy();
}
inline void ModelDynamicBatching::clear_default_queue_policy() {
  if (GetArena() == nullptr && default_queue_policy_ != nullptr) {
    delete default_queue_policy_;
  }
  default_queue_policy_ = nullptr;
}
inline const ::inference::ModelQueuePolicy& ModelDynamicBatching::_internal_default_queue_policy() const {
  const ::inference::ModelQueuePolicy* p = default_queue_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelQueuePolicy&>(
      ::inference::_ModelQueuePolicy_default_instance_);
}
inline const ::inference::ModelQueuePolicy& ModelDynamicBatching::default_queue_policy() const {
  // @@protoc_insertion_point(field_get:inference.ModelDynamicBatching.default_queue_policy)
  return _internal_default_queue_policy();
}
inline void ModelDynamicBatching::unsafe_arena_set_allocated_default_queue_policy(
    ::inference::ModelQueuePolicy* default_queue_policy) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_queue_policy_);
  }
  default_queue_policy_ = default_queue_policy;
  if (default_queue_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelDynamicBatching.default_queue_policy)
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::release_default_queue_policy() {
  
  ::inference::ModelQueuePolicy* temp = default_queue_policy_;
  default_queue_policy_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::unsafe_arena_release_default_queue_policy() {
  // @@protoc_insertion_point(field_release:inference.ModelDynamicBatching.default_queue_policy)
  
  ::inference::ModelQueuePolicy* temp = default_queue_policy_;
  default_queue_policy_ = nullptr;
  return temp;
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::_internal_mutable_default_queue_policy() {
  
  if (default_queue_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelQueuePolicy>(GetArena());
    default_queue_policy_ = p;
  }
  return default_queue_policy_;
}
inline ::inference::ModelQueuePolicy* ModelDynamicBatching::mutable_default_queue_policy() {
  // @@protoc_insertion_point(field_mutable:inference.ModelDynamicBatching.default_queue_policy)
  return _internal_mutable_default_queue_policy();
}
inline void ModelDynamicBatching::set_allocated_default_queue_policy(::inference::ModelQueuePolicy* default_queue_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete default_queue_policy_;
  }
  if (default_queue_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(default_queue_policy);
    if (message_arena != submessage_arena) {
      default_queue_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_queue_policy, submessage_arena);
    }
    
  } else {
    
  }
  default_queue_policy_ = default_queue_policy;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelDynamicBatching.default_queue_policy)
}

// map<uint32, .inference.ModelQueuePolicy> priority_queue_policy = 7;
inline int ModelDynamicBatching::_internal_priority_queue_policy_size() const {
  return priority_queue_policy_.size();
}
inline int ModelDynamicBatching::priority_queue_policy_size() const {
  return _internal_priority_queue_policy_size();
}
inline void ModelDynamicBatching::clear_priority_queue_policy() {
  priority_queue_policy_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >&
ModelDynamicBatching::_internal_priority_queue_policy() const {
  return priority_queue_policy_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >&
ModelDynamicBatching::priority_queue_policy() const {
  // @@protoc_insertion_point(field_map:inference.ModelDynamicBatching.priority_queue_policy)
  return _internal_priority_queue_policy();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >*
ModelDynamicBatching::_internal_mutable_priority_queue_policy() {
  return priority_queue_policy_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::inference::ModelQueuePolicy >*
ModelDynamicBatching::mutable_priority_queue_policy() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelDynamicBatching.priority_queue_policy)
  return _internal_mutable_priority_queue_policy();
}

// -------------------------------------------------------------------

// ModelSequenceBatching_Control

// .inference.ModelSequenceBatching.Control.Kind kind = 1;
inline void ModelSequenceBatching_Control::clear_kind() {
  kind_ = 0;
}
inline ::inference::ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::_internal_kind() const {
  return static_cast< ::inference::ModelSequenceBatching_Control_Kind >(kind_);
}
inline ::inference::ModelSequenceBatching_Control_Kind ModelSequenceBatching_Control::kind() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.kind)
  return _internal_kind();
}
inline void ModelSequenceBatching_Control::_internal_set_kind(::inference::ModelSequenceBatching_Control_Kind value) {
  
  kind_ = value;
}
inline void ModelSequenceBatching_Control::set_kind(::inference::ModelSequenceBatching_Control_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.kind)
}

// repeated int32 int32_false_true = 2;
inline int ModelSequenceBatching_Control::_internal_int32_false_true_size() const {
  return int32_false_true_.size();
}
inline int ModelSequenceBatching_Control::int32_false_true_size() const {
  return _internal_int32_false_true_size();
}
inline void ModelSequenceBatching_Control::clear_int32_false_true() {
  int32_false_true_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelSequenceBatching_Control::_internal_int32_false_true(int index) const {
  return int32_false_true_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelSequenceBatching_Control::int32_false_true(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.int32_false_true)
  return _internal_int32_false_true(index);
}
inline void ModelSequenceBatching_Control::set_int32_false_true(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_false_true_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.int32_false_true)
}
inline void ModelSequenceBatching_Control::_internal_add_int32_false_true(::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_false_true_.Add(value);
}
inline void ModelSequenceBatching_Control::add_int32_false_true(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_int32_false_true(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.Control.int32_false_true)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelSequenceBatching_Control::_internal_int32_false_true() const {
  return int32_false_true_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelSequenceBatching_Control::int32_false_true() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.Control.int32_false_true)
  return _internal_int32_false_true();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelSequenceBatching_Control::_internal_mutable_int32_false_true() {
  return &int32_false_true_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelSequenceBatching_Control::mutable_int32_false_true() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.Control.int32_false_true)
  return _internal_mutable_int32_false_true();
}

// repeated float fp32_false_true = 3;
inline int ModelSequenceBatching_Control::_internal_fp32_false_true_size() const {
  return fp32_false_true_.size();
}
inline int ModelSequenceBatching_Control::fp32_false_true_size() const {
  return _internal_fp32_false_true_size();
}
inline void ModelSequenceBatching_Control::clear_fp32_false_true() {
  fp32_false_true_.Clear();
}
inline float ModelSequenceBatching_Control::_internal_fp32_false_true(int index) const {
  return fp32_false_true_.Get(index);
}
inline float ModelSequenceBatching_Control::fp32_false_true(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.fp32_false_true)
  return _internal_fp32_false_true(index);
}
inline void ModelSequenceBatching_Control::set_fp32_false_true(int index, float value) {
  fp32_false_true_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.fp32_false_true)
}
inline void ModelSequenceBatching_Control::_internal_add_fp32_false_true(float value) {
  fp32_false_true_.Add(value);
}
inline void ModelSequenceBatching_Control::add_fp32_false_true(float value) {
  _internal_add_fp32_false_true(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.Control.fp32_false_true)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ModelSequenceBatching_Control::_internal_fp32_false_true() const {
  return fp32_false_true_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ModelSequenceBatching_Control::fp32_false_true() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.Control.fp32_false_true)
  return _internal_fp32_false_true();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ModelSequenceBatching_Control::_internal_mutable_fp32_false_true() {
  return &fp32_false_true_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ModelSequenceBatching_Control::mutable_fp32_false_true() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.Control.fp32_false_true)
  return _internal_mutable_fp32_false_true();
}

// .inference.DataType data_type = 4;
inline void ModelSequenceBatching_Control::clear_data_type() {
  data_type_ = 0;
}
inline ::inference::DataType ModelSequenceBatching_Control::_internal_data_type() const {
  return static_cast< ::inference::DataType >(data_type_);
}
inline ::inference::DataType ModelSequenceBatching_Control::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.Control.data_type)
  return _internal_data_type();
}
inline void ModelSequenceBatching_Control::_internal_set_data_type(::inference::DataType value) {
  
  data_type_ = value;
}
inline void ModelSequenceBatching_Control::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.Control.data_type)
}

// -------------------------------------------------------------------

// ModelSequenceBatching_ControlInput

// string name = 1;
inline void ModelSequenceBatching_ControlInput::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelSequenceBatching_ControlInput::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.ControlInput.name)
  return _internal_name();
}
inline void ModelSequenceBatching_ControlInput::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.ControlInput.name)
}
inline std::string* ModelSequenceBatching_ControlInput::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.ControlInput.name)
  return _internal_mutable_name();
}
inline const std::string& ModelSequenceBatching_ControlInput::_internal_name() const {
  return name_.Get();
}
inline void ModelSequenceBatching_ControlInput::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelSequenceBatching_ControlInput::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelSequenceBatching.ControlInput.name)
}
inline void ModelSequenceBatching_ControlInput::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelSequenceBatching.ControlInput.name)
}
inline void ModelSequenceBatching_ControlInput::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelSequenceBatching.ControlInput.name)
}
inline std::string* ModelSequenceBatching_ControlInput::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelSequenceBatching_ControlInput::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.ControlInput.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelSequenceBatching_ControlInput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelSequenceBatching.ControlInput.name)
}

// repeated .inference.ModelSequenceBatching.Control control = 2;
inline int ModelSequenceBatching_ControlInput::_internal_control_size() const {
  return control_.size();
}
inline int ModelSequenceBatching_ControlInput::control_size() const {
  return _internal_control_size();
}
inline void ModelSequenceBatching_ControlInput::clear_control() {
  control_.Clear();
}
inline ::inference::ModelSequenceBatching_Control* ModelSequenceBatching_ControlInput::mutable_control(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.ControlInput.control)
  return control_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >*
ModelSequenceBatching_ControlInput::mutable_control() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.ControlInput.control)
  return &control_;
}
inline const ::inference::ModelSequenceBatching_Control& ModelSequenceBatching_ControlInput::_internal_control(int index) const {
  return control_.Get(index);
}
inline const ::inference::ModelSequenceBatching_Control& ModelSequenceBatching_ControlInput::control(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.ControlInput.control)
  return _internal_control(index);
}
inline ::inference::ModelSequenceBatching_Control* ModelSequenceBatching_ControlInput::_internal_add_control() {
  return control_.Add();
}
inline ::inference::ModelSequenceBatching_Control* ModelSequenceBatching_ControlInput::add_control() {
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.ControlInput.control)
  return _internal_add_control();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_Control >&
ModelSequenceBatching_ControlInput::control() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.ControlInput.control)
  return control_;
}

// -------------------------------------------------------------------

// ModelSequenceBatching_StrategyDirect

// uint64 max_queue_delay_microseconds = 1;
inline void ModelSequenceBatching_StrategyDirect::clear_max_queue_delay_microseconds() {
  max_queue_delay_microseconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelSequenceBatching_StrategyDirect::_internal_max_queue_delay_microseconds() const {
  return max_queue_delay_microseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelSequenceBatching_StrategyDirect::max_queue_delay_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyDirect.max_queue_delay_microseconds)
  return _internal_max_queue_delay_microseconds();
}
inline void ModelSequenceBatching_StrategyDirect::_internal_set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_queue_delay_microseconds_ = value;
}
inline void ModelSequenceBatching_StrategyDirect::set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_queue_delay_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyDirect.max_queue_delay_microseconds)
}

// float minimum_slot_utilization = 2;
inline void ModelSequenceBatching_StrategyDirect::clear_minimum_slot_utilization() {
  minimum_slot_utilization_ = 0;
}
inline float ModelSequenceBatching_StrategyDirect::_internal_minimum_slot_utilization() const {
  return minimum_slot_utilization_;
}
inline float ModelSequenceBatching_StrategyDirect::minimum_slot_utilization() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyDirect.minimum_slot_utilization)
  return _internal_minimum_slot_utilization();
}
inline void ModelSequenceBatching_StrategyDirect::_internal_set_minimum_slot_utilization(float value) {
  
  minimum_slot_utilization_ = value;
}
inline void ModelSequenceBatching_StrategyDirect::set_minimum_slot_utilization(float value) {
  _internal_set_minimum_slot_utilization(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyDirect.minimum_slot_utilization)
}

// -------------------------------------------------------------------

// ModelSequenceBatching_StrategyOldest

// int32 max_candidate_sequences = 1;
inline void ModelSequenceBatching_StrategyOldest::clear_max_candidate_sequences() {
  max_candidate_sequences_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelSequenceBatching_StrategyOldest::_internal_max_candidate_sequences() const {
  return max_candidate_sequences_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelSequenceBatching_StrategyOldest::max_candidate_sequences() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyOldest.max_candidate_sequences)
  return _internal_max_candidate_sequences();
}
inline void ModelSequenceBatching_StrategyOldest::_internal_set_max_candidate_sequences(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_candidate_sequences_ = value;
}
inline void ModelSequenceBatching_StrategyOldest::set_max_candidate_sequences(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_candidate_sequences(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyOldest.max_candidate_sequences)
}

// repeated int32 preferred_batch_size = 2;
inline int ModelSequenceBatching_StrategyOldest::_internal_preferred_batch_size_size() const {
  return preferred_batch_size_.size();
}
inline int ModelSequenceBatching_StrategyOldest::preferred_batch_size_size() const {
  return _internal_preferred_batch_size_size();
}
inline void ModelSequenceBatching_StrategyOldest::clear_preferred_batch_size() {
  preferred_batch_size_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelSequenceBatching_StrategyOldest::_internal_preferred_batch_size(int index) const {
  return preferred_batch_size_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelSequenceBatching_StrategyOldest::preferred_batch_size(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
  return _internal_preferred_batch_size(index);
}
inline void ModelSequenceBatching_StrategyOldest::set_preferred_batch_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  preferred_batch_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
}
inline void ModelSequenceBatching_StrategyOldest::_internal_add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  preferred_batch_size_.Add(value);
}
inline void ModelSequenceBatching_StrategyOldest::add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_preferred_batch_size(value);
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelSequenceBatching_StrategyOldest::_internal_preferred_batch_size() const {
  return preferred_batch_size_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelSequenceBatching_StrategyOldest::preferred_batch_size() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
  return _internal_preferred_batch_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelSequenceBatching_StrategyOldest::_internal_mutable_preferred_batch_size() {
  return &preferred_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelSequenceBatching_StrategyOldest::mutable_preferred_batch_size() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.StrategyOldest.preferred_batch_size)
  return _internal_mutable_preferred_batch_size();
}

// uint64 max_queue_delay_microseconds = 3;
inline void ModelSequenceBatching_StrategyOldest::clear_max_queue_delay_microseconds() {
  max_queue_delay_microseconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelSequenceBatching_StrategyOldest::_internal_max_queue_delay_microseconds() const {
  return max_queue_delay_microseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelSequenceBatching_StrategyOldest::max_queue_delay_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.StrategyOldest.max_queue_delay_microseconds)
  return _internal_max_queue_delay_microseconds();
}
inline void ModelSequenceBatching_StrategyOldest::_internal_set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_queue_delay_microseconds_ = value;
}
inline void ModelSequenceBatching_StrategyOldest::set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_queue_delay_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.StrategyOldest.max_queue_delay_microseconds)
}

// -------------------------------------------------------------------

// ModelSequenceBatching

// .inference.ModelSequenceBatching.StrategyDirect direct = 3;
inline bool ModelSequenceBatching::_internal_has_direct() const {
  return strategy_choice_case() == kDirect;
}
inline bool ModelSequenceBatching::has_direct() const {
  return _internal_has_direct();
}
inline void ModelSequenceBatching::set_has_direct() {
  _oneof_case_[0] = kDirect;
}
inline void ModelSequenceBatching::clear_direct() {
  if (_internal_has_direct()) {
    if (GetArena() == nullptr) {
      delete strategy_choice_.direct_;
    }
    clear_has_strategy_choice();
  }
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::release_direct() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.direct)
  if (_internal_has_direct()) {
    clear_has_strategy_choice();
      ::inference::ModelSequenceBatching_StrategyDirect* temp = strategy_choice_.direct_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    strategy_choice_.direct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelSequenceBatching_StrategyDirect& ModelSequenceBatching::_internal_direct() const {
  return _internal_has_direct()
      ? *strategy_choice_.direct_
      : reinterpret_cast< ::inference::ModelSequenceBatching_StrategyDirect&>(::inference::_ModelSequenceBatching_StrategyDirect_default_instance_);
}
inline const ::inference::ModelSequenceBatching_StrategyDirect& ModelSequenceBatching::direct() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.direct)
  return _internal_direct();
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::unsafe_arena_release_direct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelSequenceBatching.direct)
  if (_internal_has_direct()) {
    clear_has_strategy_choice();
    ::inference::ModelSequenceBatching_StrategyDirect* temp = strategy_choice_.direct_;
    strategy_choice_.direct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelSequenceBatching::unsafe_arena_set_allocated_direct(::inference::ModelSequenceBatching_StrategyDirect* direct) {
  clear_strategy_choice();
  if (direct) {
    set_has_direct();
    strategy_choice_.direct_ = direct;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelSequenceBatching.direct)
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::_internal_mutable_direct() {
  if (!_internal_has_direct()) {
    clear_strategy_choice();
    set_has_direct();
    strategy_choice_.direct_ = CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyDirect >(GetArena());
  }
  return strategy_choice_.direct_;
}
inline ::inference::ModelSequenceBatching_StrategyDirect* ModelSequenceBatching::mutable_direct() {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.direct)
  return _internal_mutable_direct();
}

// .inference.ModelSequenceBatching.StrategyOldest oldest = 4;
inline bool ModelSequenceBatching::_internal_has_oldest() const {
  return strategy_choice_case() == kOldest;
}
inline bool ModelSequenceBatching::has_oldest() const {
  return _internal_has_oldest();
}
inline void ModelSequenceBatching::set_has_oldest() {
  _oneof_case_[0] = kOldest;
}
inline void ModelSequenceBatching::clear_oldest() {
  if (_internal_has_oldest()) {
    if (GetArena() == nullptr) {
      delete strategy_choice_.oldest_;
    }
    clear_has_strategy_choice();
  }
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::release_oldest() {
  // @@protoc_insertion_point(field_release:inference.ModelSequenceBatching.oldest)
  if (_internal_has_oldest()) {
    clear_has_strategy_choice();
      ::inference::ModelSequenceBatching_StrategyOldest* temp = strategy_choice_.oldest_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    strategy_choice_.oldest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelSequenceBatching_StrategyOldest& ModelSequenceBatching::_internal_oldest() const {
  return _internal_has_oldest()
      ? *strategy_choice_.oldest_
      : reinterpret_cast< ::inference::ModelSequenceBatching_StrategyOldest&>(::inference::_ModelSequenceBatching_StrategyOldest_default_instance_);
}
inline const ::inference::ModelSequenceBatching_StrategyOldest& ModelSequenceBatching::oldest() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.oldest)
  return _internal_oldest();
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::unsafe_arena_release_oldest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelSequenceBatching.oldest)
  if (_internal_has_oldest()) {
    clear_has_strategy_choice();
    ::inference::ModelSequenceBatching_StrategyOldest* temp = strategy_choice_.oldest_;
    strategy_choice_.oldest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelSequenceBatching::unsafe_arena_set_allocated_oldest(::inference::ModelSequenceBatching_StrategyOldest* oldest) {
  clear_strategy_choice();
  if (oldest) {
    set_has_oldest();
    strategy_choice_.oldest_ = oldest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelSequenceBatching.oldest)
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::_internal_mutable_oldest() {
  if (!_internal_has_oldest()) {
    clear_strategy_choice();
    set_has_oldest();
    strategy_choice_.oldest_ = CreateMaybeMessage< ::inference::ModelSequenceBatching_StrategyOldest >(GetArena());
  }
  return strategy_choice_.oldest_;
}
inline ::inference::ModelSequenceBatching_StrategyOldest* ModelSequenceBatching::mutable_oldest() {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.oldest)
  return _internal_mutable_oldest();
}

// uint64 max_sequence_idle_microseconds = 1;
inline void ModelSequenceBatching::clear_max_sequence_idle_microseconds() {
  max_sequence_idle_microseconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelSequenceBatching::_internal_max_sequence_idle_microseconds() const {
  return max_sequence_idle_microseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ModelSequenceBatching::max_sequence_idle_microseconds() const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.max_sequence_idle_microseconds)
  return _internal_max_sequence_idle_microseconds();
}
inline void ModelSequenceBatching::_internal_set_max_sequence_idle_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_sequence_idle_microseconds_ = value;
}
inline void ModelSequenceBatching::set_max_sequence_idle_microseconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_sequence_idle_microseconds(value);
  // @@protoc_insertion_point(field_set:inference.ModelSequenceBatching.max_sequence_idle_microseconds)
}

// repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;
inline int ModelSequenceBatching::_internal_control_input_size() const {
  return control_input_.size();
}
inline int ModelSequenceBatching::control_input_size() const {
  return _internal_control_input_size();
}
inline void ModelSequenceBatching::clear_control_input() {
  control_input_.Clear();
}
inline ::inference::ModelSequenceBatching_ControlInput* ModelSequenceBatching::mutable_control_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelSequenceBatching.control_input)
  return control_input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >*
ModelSequenceBatching::mutable_control_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelSequenceBatching.control_input)
  return &control_input_;
}
inline const ::inference::ModelSequenceBatching_ControlInput& ModelSequenceBatching::_internal_control_input(int index) const {
  return control_input_.Get(index);
}
inline const ::inference::ModelSequenceBatching_ControlInput& ModelSequenceBatching::control_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelSequenceBatching.control_input)
  return _internal_control_input(index);
}
inline ::inference::ModelSequenceBatching_ControlInput* ModelSequenceBatching::_internal_add_control_input() {
  return control_input_.Add();
}
inline ::inference::ModelSequenceBatching_ControlInput* ModelSequenceBatching::add_control_input() {
  // @@protoc_insertion_point(field_add:inference.ModelSequenceBatching.control_input)
  return _internal_add_control_input();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelSequenceBatching_ControlInput >&
ModelSequenceBatching::control_input() const {
  // @@protoc_insertion_point(field_list:inference.ModelSequenceBatching.control_input)
  return control_input_;
}

inline bool ModelSequenceBatching::has_strategy_choice() const {
  return strategy_choice_case() != STRATEGY_CHOICE_NOT_SET;
}
inline void ModelSequenceBatching::clear_has_strategy_choice() {
  _oneof_case_[0] = STRATEGY_CHOICE_NOT_SET;
}
inline ModelSequenceBatching::StrategyChoiceCase ModelSequenceBatching::strategy_choice_case() const {
  return ModelSequenceBatching::StrategyChoiceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelEnsembling_Step

// string model_name = 1;
inline void ModelEnsembling_Step::clear_model_name() {
  model_name_.ClearToEmpty();
}
inline const std::string& ModelEnsembling_Step::model_name() const {
  // @@protoc_insertion_point(field_get:inference.ModelEnsembling.Step.model_name)
  return _internal_model_name();
}
inline void ModelEnsembling_Step::set_model_name(const std::string& value) {
  _internal_set_model_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelEnsembling.Step.model_name)
}
inline std::string* ModelEnsembling_Step::mutable_model_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelEnsembling.Step.model_name)
  return _internal_mutable_model_name();
}
inline const std::string& ModelEnsembling_Step::_internal_model_name() const {
  return model_name_.Get();
}
inline void ModelEnsembling_Step::_internal_set_model_name(const std::string& value) {
  
  model_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelEnsembling_Step::set_model_name(std::string&& value) {
  
  model_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelEnsembling.Step.model_name)
}
inline void ModelEnsembling_Step::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelEnsembling.Step.model_name)
}
inline void ModelEnsembling_Step::set_model_name(const char* value,
    size_t size) {
  
  model_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelEnsembling.Step.model_name)
}
inline std::string* ModelEnsembling_Step::_internal_mutable_model_name() {
  
  return model_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelEnsembling_Step::release_model_name() {
  // @@protoc_insertion_point(field_release:inference.ModelEnsembling.Step.model_name)
  return model_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelEnsembling_Step::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  model_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelEnsembling.Step.model_name)
}

// int64 model_version = 2;
inline void ModelEnsembling_Step::clear_model_version() {
  model_version_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelEnsembling_Step::_internal_model_version() const {
  return model_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelEnsembling_Step::model_version() const {
  // @@protoc_insertion_point(field_get:inference.ModelEnsembling.Step.model_version)
  return _internal_model_version();
}
inline void ModelEnsembling_Step::_internal_set_model_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  model_version_ = value;
}
inline void ModelEnsembling_Step::set_model_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_model_version(value);
  // @@protoc_insertion_point(field_set:inference.ModelEnsembling.Step.model_version)
}

// map<string, string> input_map = 3;
inline int ModelEnsembling_Step::_internal_input_map_size() const {
  return input_map_.size();
}
inline int ModelEnsembling_Step::input_map_size() const {
  return _internal_input_map_size();
}
inline void ModelEnsembling_Step::clear_input_map() {
  input_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::_internal_input_map() const {
  return input_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::input_map() const {
  // @@protoc_insertion_point(field_map:inference.ModelEnsembling.Step.input_map)
  return _internal_input_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::_internal_mutable_input_map() {
  return input_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::mutable_input_map() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelEnsembling.Step.input_map)
  return _internal_mutable_input_map();
}

// map<string, string> output_map = 4;
inline int ModelEnsembling_Step::_internal_output_map_size() const {
  return output_map_.size();
}
inline int ModelEnsembling_Step::output_map_size() const {
  return _internal_output_map_size();
}
inline void ModelEnsembling_Step::clear_output_map() {
  output_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::_internal_output_map() const {
  return output_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelEnsembling_Step::output_map() const {
  // @@protoc_insertion_point(field_map:inference.ModelEnsembling.Step.output_map)
  return _internal_output_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::_internal_mutable_output_map() {
  return output_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelEnsembling_Step::mutable_output_map() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelEnsembling.Step.output_map)
  return _internal_mutable_output_map();
}

// -------------------------------------------------------------------

// ModelEnsembling

// repeated .inference.ModelEnsembling.Step step = 1;
inline int ModelEnsembling::_internal_step_size() const {
  return step_.size();
}
inline int ModelEnsembling::step_size() const {
  return _internal_step_size();
}
inline void ModelEnsembling::clear_step() {
  step_.Clear();
}
inline ::inference::ModelEnsembling_Step* ModelEnsembling::mutable_step(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelEnsembling.step)
  return step_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >*
ModelEnsembling::mutable_step() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelEnsembling.step)
  return &step_;
}
inline const ::inference::ModelEnsembling_Step& ModelEnsembling::_internal_step(int index) const {
  return step_.Get(index);
}
inline const ::inference::ModelEnsembling_Step& ModelEnsembling::step(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelEnsembling.step)
  return _internal_step(index);
}
inline ::inference::ModelEnsembling_Step* ModelEnsembling::_internal_add_step() {
  return step_.Add();
}
inline ::inference::ModelEnsembling_Step* ModelEnsembling::add_step() {
  // @@protoc_insertion_point(field_add:inference.ModelEnsembling.step)
  return _internal_add_step();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelEnsembling_Step >&
ModelEnsembling::step() const {
  // @@protoc_insertion_point(field_list:inference.ModelEnsembling.step)
  return step_;
}

// -------------------------------------------------------------------

// ModelParameter

// string string_value = 1;
inline void ModelParameter::clear_string_value() {
  string_value_.ClearToEmpty();
}
inline const std::string& ModelParameter::string_value() const {
  // @@protoc_insertion_point(field_get:inference.ModelParameter.string_value)
  return _internal_string_value();
}
inline void ModelParameter::set_string_value(const std::string& value) {
  _internal_set_string_value(value);
  // @@protoc_insertion_point(field_set:inference.ModelParameter.string_value)
}
inline std::string* ModelParameter::mutable_string_value() {
  // @@protoc_insertion_point(field_mutable:inference.ModelParameter.string_value)
  return _internal_mutable_string_value();
}
inline const std::string& ModelParameter::_internal_string_value() const {
  return string_value_.Get();
}
inline void ModelParameter::_internal_set_string_value(const std::string& value) {
  
  string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelParameter::set_string_value(std::string&& value) {
  
  string_value_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelParameter.string_value)
}
inline void ModelParameter::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelParameter.string_value)
}
inline void ModelParameter::set_string_value(const char* value,
    size_t size) {
  
  string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelParameter.string_value)
}
inline std::string* ModelParameter::_internal_mutable_string_value() {
  
  return string_value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelParameter::release_string_value() {
  // @@protoc_insertion_point(field_release:inference.ModelParameter.string_value)
  return string_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelParameter::set_allocated_string_value(std::string* string_value) {
  if (string_value != nullptr) {
    
  } else {
    
  }
  string_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), string_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelParameter.string_value)
}

// -------------------------------------------------------------------

// ModelWarmup_Input

// .inference.DataType data_type = 1;
inline void ModelWarmup_Input::clear_data_type() {
  data_type_ = 0;
}
inline ::inference::DataType ModelWarmup_Input::_internal_data_type() const {
  return static_cast< ::inference::DataType >(data_type_);
}
inline ::inference::DataType ModelWarmup_Input::data_type() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.data_type)
  return _internal_data_type();
}
inline void ModelWarmup_Input::_internal_set_data_type(::inference::DataType value) {
  
  data_type_ = value;
}
inline void ModelWarmup_Input::set_data_type(::inference::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.data_type)
}

// repeated int64 dims = 2;
inline int ModelWarmup_Input::_internal_dims_size() const {
  return dims_.size();
}
inline int ModelWarmup_Input::dims_size() const {
  return _internal_dims_size();
}
inline void ModelWarmup_Input::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelWarmup_Input::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelWarmup_Input::dims(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.dims)
  return _internal_dims(index);
}
inline void ModelWarmup_Input::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.dims)
}
inline void ModelWarmup_Input::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
}
inline void ModelWarmup_Input::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:inference.ModelWarmup.Input.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelWarmup_Input::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelWarmup_Input::dims() const {
  // @@protoc_insertion_point(field_list:inference.ModelWarmup.Input.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelWarmup_Input::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelWarmup_Input::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelWarmup.Input.dims)
  return _internal_mutable_dims();
}

// bool zero_data = 3;
inline bool ModelWarmup_Input::_internal_has_zero_data() const {
  return input_data_type_case() == kZeroData;
}
inline void ModelWarmup_Input::set_has_zero_data() {
  _oneof_case_[0] = kZeroData;
}
inline void ModelWarmup_Input::clear_zero_data() {
  if (_internal_has_zero_data()) {
    input_data_type_.zero_data_ = false;
    clear_has_input_data_type();
  }
}
inline bool ModelWarmup_Input::_internal_zero_data() const {
  if (_internal_has_zero_data()) {
    return input_data_type_.zero_data_;
  }
  return false;
}
inline void ModelWarmup_Input::_internal_set_zero_data(bool value) {
  if (!_internal_has_zero_data()) {
    clear_input_data_type();
    set_has_zero_data();
  }
  input_data_type_.zero_data_ = value;
}
inline bool ModelWarmup_Input::zero_data() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.zero_data)
  return _internal_zero_data();
}
inline void ModelWarmup_Input::set_zero_data(bool value) {
  _internal_set_zero_data(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.zero_data)
}

// bool random_data = 4;
inline bool ModelWarmup_Input::_internal_has_random_data() const {
  return input_data_type_case() == kRandomData;
}
inline void ModelWarmup_Input::set_has_random_data() {
  _oneof_case_[0] = kRandomData;
}
inline void ModelWarmup_Input::clear_random_data() {
  if (_internal_has_random_data()) {
    input_data_type_.random_data_ = false;
    clear_has_input_data_type();
  }
}
inline bool ModelWarmup_Input::_internal_random_data() const {
  if (_internal_has_random_data()) {
    return input_data_type_.random_data_;
  }
  return false;
}
inline void ModelWarmup_Input::_internal_set_random_data(bool value) {
  if (!_internal_has_random_data()) {
    clear_input_data_type();
    set_has_random_data();
  }
  input_data_type_.random_data_ = value;
}
inline bool ModelWarmup_Input::random_data() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.random_data)
  return _internal_random_data();
}
inline void ModelWarmup_Input::set_random_data(bool value) {
  _internal_set_random_data(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.random_data)
}

// string input_data_file = 5;
inline bool ModelWarmup_Input::_internal_has_input_data_file() const {
  return input_data_type_case() == kInputDataFile;
}
inline void ModelWarmup_Input::set_has_input_data_file() {
  _oneof_case_[0] = kInputDataFile;
}
inline void ModelWarmup_Input::clear_input_data_file() {
  if (_internal_has_input_data_file()) {
    input_data_type_.input_data_file_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_input_data_type();
  }
}
inline const std::string& ModelWarmup_Input::input_data_file() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.Input.input_data_file)
  return _internal_input_data_file();
}
inline void ModelWarmup_Input::set_input_data_file(const std::string& value) {
  _internal_set_input_data_file(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.input_data_file)
}
inline std::string* ModelWarmup_Input::mutable_input_data_file() {
  // @@protoc_insertion_point(field_mutable:inference.ModelWarmup.Input.input_data_file)
  return _internal_mutable_input_data_file();
}
inline const std::string& ModelWarmup_Input::_internal_input_data_file() const {
  if (_internal_has_input_data_file()) {
    return input_data_type_.input_data_file_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ModelWarmup_Input::_internal_set_input_data_file(const std::string& value) {
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    input_data_type_.input_data_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_data_type_.input_data_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelWarmup_Input::set_input_data_file(std::string&& value) {
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.Input.input_data_file)
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    input_data_type_.input_data_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_data_type_.input_data_file_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelWarmup.Input.input_data_file)
}
inline void ModelWarmup_Input::set_input_data_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    input_data_type_.input_data_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_data_type_.input_data_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelWarmup.Input.input_data_file)
}
inline void ModelWarmup_Input::set_input_data_file(const char* value,
                             size_t size) {
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    input_data_type_.input_data_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_data_type_.input_data_file_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelWarmup.Input.input_data_file)
}
inline std::string* ModelWarmup_Input::_internal_mutable_input_data_file() {
  if (!_internal_has_input_data_file()) {
    clear_input_data_type();
    set_has_input_data_file();
    input_data_type_.input_data_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return input_data_type_.input_data_file_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelWarmup_Input::release_input_data_file() {
  // @@protoc_insertion_point(field_release:inference.ModelWarmup.Input.input_data_file)
  if (_internal_has_input_data_file()) {
    clear_has_input_data_type();
    return input_data_type_.input_data_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void ModelWarmup_Input::set_allocated_input_data_file(std::string* input_data_file) {
  if (has_input_data_type()) {
    clear_input_data_type();
  }
  if (input_data_file != nullptr) {
    set_has_input_data_file();
    input_data_type_.input_data_file_.UnsafeSetDefault(input_data_file);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(input_data_file);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:inference.ModelWarmup.Input.input_data_file)
}

inline bool ModelWarmup_Input::has_input_data_type() const {
  return input_data_type_case() != INPUT_DATA_TYPE_NOT_SET;
}
inline void ModelWarmup_Input::clear_has_input_data_type() {
  _oneof_case_[0] = INPUT_DATA_TYPE_NOT_SET;
}
inline ModelWarmup_Input::InputDataTypeCase ModelWarmup_Input::input_data_type_case() const {
  return ModelWarmup_Input::InputDataTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelWarmup

// string name = 1;
inline void ModelWarmup::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelWarmup::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.name)
  return _internal_name();
}
inline void ModelWarmup::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.name)
}
inline std::string* ModelWarmup::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelWarmup.name)
  return _internal_mutable_name();
}
inline const std::string& ModelWarmup::_internal_name() const {
  return name_.Get();
}
inline void ModelWarmup::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelWarmup::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelWarmup.name)
}
inline void ModelWarmup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelWarmup.name)
}
inline void ModelWarmup::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelWarmup.name)
}
inline std::string* ModelWarmup::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelWarmup::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelWarmup.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelWarmup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelWarmup.name)
}

// uint32 batch_size = 2;
inline void ModelWarmup::clear_batch_size() {
  batch_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelWarmup::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ModelWarmup::batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelWarmup.batch_size)
  return _internal_batch_size();
}
inline void ModelWarmup::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  batch_size_ = value;
}
inline void ModelWarmup::set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelWarmup.batch_size)
}

// map<string, .inference.ModelWarmup.Input> inputs = 3;
inline int ModelWarmup::_internal_inputs_size() const {
  return inputs_.size();
}
inline int ModelWarmup::inputs_size() const {
  return _internal_inputs_size();
}
inline void ModelWarmup::clear_inputs() {
  inputs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
ModelWarmup::_internal_inputs() const {
  return inputs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >&
ModelWarmup::inputs() const {
  // @@protoc_insertion_point(field_map:inference.ModelWarmup.inputs)
  return _internal_inputs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
ModelWarmup::_internal_mutable_inputs() {
  return inputs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelWarmup_Input >*
ModelWarmup::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelWarmup.inputs)
  return _internal_mutable_inputs();
}

// -------------------------------------------------------------------

// ModelOperations

// repeated string op_library_filename = 1;
inline int ModelOperations::_internal_op_library_filename_size() const {
  return op_library_filename_.size();
}
inline int ModelOperations::op_library_filename_size() const {
  return _internal_op_library_filename_size();
}
inline void ModelOperations::clear_op_library_filename() {
  op_library_filename_.Clear();
}
inline std::string* ModelOperations::add_op_library_filename() {
  // @@protoc_insertion_point(field_add_mutable:inference.ModelOperations.op_library_filename)
  return _internal_add_op_library_filename();
}
inline const std::string& ModelOperations::_internal_op_library_filename(int index) const {
  return op_library_filename_.Get(index);
}
inline const std::string& ModelOperations::op_library_filename(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelOperations.op_library_filename)
  return _internal_op_library_filename(index);
}
inline std::string* ModelOperations::mutable_op_library_filename(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelOperations.op_library_filename)
  return op_library_filename_.Mutable(index);
}
inline void ModelOperations::set_op_library_filename(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:inference.ModelOperations.op_library_filename)
  op_library_filename_.Mutable(index)->assign(value);
}
inline void ModelOperations::set_op_library_filename(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:inference.ModelOperations.op_library_filename)
  op_library_filename_.Mutable(index)->assign(std::move(value));
}
inline void ModelOperations::set_op_library_filename(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  op_library_filename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::set_op_library_filename(int index, const char* value, size_t size) {
  op_library_filename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:inference.ModelOperations.op_library_filename)
}
inline std::string* ModelOperations::_internal_add_op_library_filename() {
  return op_library_filename_.Add();
}
inline void ModelOperations::add_op_library_filename(const std::string& value) {
  op_library_filename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::add_op_library_filename(std::string&& value) {
  op_library_filename_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::add_op_library_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  op_library_filename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:inference.ModelOperations.op_library_filename)
}
inline void ModelOperations::add_op_library_filename(const char* value, size_t size) {
  op_library_filename_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:inference.ModelOperations.op_library_filename)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelOperations::op_library_filename() const {
  // @@protoc_insertion_point(field_list:inference.ModelOperations.op_library_filename)
  return op_library_filename_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelOperations::mutable_op_library_filename() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelOperations.op_library_filename)
  return &op_library_filename_;
}

// -------------------------------------------------------------------

// ModelTransactionPolicy

// bool decoupled = 1;
inline void ModelTransactionPolicy::clear_decoupled() {
  decoupled_ = false;
}
inline bool ModelTransactionPolicy::_internal_decoupled() const {
  return decoupled_;
}
inline bool ModelTransactionPolicy::decoupled() const {
  // @@protoc_insertion_point(field_get:inference.ModelTransactionPolicy.decoupled)
  return _internal_decoupled();
}
inline void ModelTransactionPolicy::_internal_set_decoupled(bool value) {
  
  decoupled_ = value;
}
inline void ModelTransactionPolicy::set_decoupled(bool value) {
  _internal_set_decoupled(value);
  // @@protoc_insertion_point(field_set:inference.ModelTransactionPolicy.decoupled)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelConfig

// string name = 1;
inline void ModelConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ModelConfig::name() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.name)
  return _internal_name();
}
inline void ModelConfig::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:inference.ModelConfig.name)
}
inline std::string* ModelConfig::mutable_name() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.name)
  return _internal_mutable_name();
}
inline const std::string& ModelConfig::_internal_name() const {
  return name_.Get();
}
inline void ModelConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelConfig::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelConfig.name)
}
inline void ModelConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelConfig.name)
}
inline void ModelConfig::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelConfig.name)
}
inline std::string* ModelConfig::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelConfig::release_name() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.name)
}

// string platform = 2;
inline void ModelConfig::clear_platform() {
  platform_.ClearToEmpty();
}
inline const std::string& ModelConfig::platform() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.platform)
  return _internal_platform();
}
inline void ModelConfig::set_platform(const std::string& value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:inference.ModelConfig.platform)
}
inline std::string* ModelConfig::mutable_platform() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.platform)
  return _internal_mutable_platform();
}
inline const std::string& ModelConfig::_internal_platform() const {
  return platform_.Get();
}
inline void ModelConfig::_internal_set_platform(const std::string& value) {
  
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelConfig::set_platform(std::string&& value) {
  
  platform_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelConfig.platform)
}
inline void ModelConfig::set_platform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelConfig.platform)
}
inline void ModelConfig::set_platform(const char* value,
    size_t size) {
  
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelConfig.platform)
}
inline std::string* ModelConfig::_internal_mutable_platform() {
  
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelConfig::release_platform() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.platform)
  return platform_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelConfig::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.platform)
}

// string backend = 17;
inline void ModelConfig::clear_backend() {
  backend_.ClearToEmpty();
}
inline const std::string& ModelConfig::backend() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.backend)
  return _internal_backend();
}
inline void ModelConfig::set_backend(const std::string& value) {
  _internal_set_backend(value);
  // @@protoc_insertion_point(field_set:inference.ModelConfig.backend)
}
inline std::string* ModelConfig::mutable_backend() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.backend)
  return _internal_mutable_backend();
}
inline const std::string& ModelConfig::_internal_backend() const {
  return backend_.Get();
}
inline void ModelConfig::_internal_set_backend(const std::string& value) {
  
  backend_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelConfig::set_backend(std::string&& value) {
  
  backend_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelConfig.backend)
}
inline void ModelConfig::set_backend(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  backend_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelConfig.backend)
}
inline void ModelConfig::set_backend(const char* value,
    size_t size) {
  
  backend_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelConfig.backend)
}
inline std::string* ModelConfig::_internal_mutable_backend() {
  
  return backend_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelConfig::release_backend() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.backend)
  return backend_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelConfig::set_allocated_backend(std::string* backend) {
  if (backend != nullptr) {
    
  } else {
    
  }
  backend_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backend,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.backend)
}

// .inference.ModelVersionPolicy version_policy = 3;
inline bool ModelConfig::_internal_has_version_policy() const {
  return this != internal_default_instance() && version_policy_ != nullptr;
}
inline bool ModelConfig::has_version_policy() const {
  return _internal_has_version_policy();
}
inline void ModelConfig::clear_version_policy() {
  if (GetArena() == nullptr && version_policy_ != nullptr) {
    delete version_policy_;
  }
  version_policy_ = nullptr;
}
inline const ::inference::ModelVersionPolicy& ModelConfig::_internal_version_policy() const {
  const ::inference::ModelVersionPolicy* p = version_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelVersionPolicy&>(
      ::inference::_ModelVersionPolicy_default_instance_);
}
inline const ::inference::ModelVersionPolicy& ModelConfig::version_policy() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.version_policy)
  return _internal_version_policy();
}
inline void ModelConfig::unsafe_arena_set_allocated_version_policy(
    ::inference::ModelVersionPolicy* version_policy) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_policy_);
  }
  version_policy_ = version_policy;
  if (version_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.version_policy)
}
inline ::inference::ModelVersionPolicy* ModelConfig::release_version_policy() {
  
  ::inference::ModelVersionPolicy* temp = version_policy_;
  version_policy_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelVersionPolicy* ModelConfig::unsafe_arena_release_version_policy() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.version_policy)
  
  ::inference::ModelVersionPolicy* temp = version_policy_;
  version_policy_ = nullptr;
  return temp;
}
inline ::inference::ModelVersionPolicy* ModelConfig::_internal_mutable_version_policy() {
  
  if (version_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelVersionPolicy>(GetArena());
    version_policy_ = p;
  }
  return version_policy_;
}
inline ::inference::ModelVersionPolicy* ModelConfig::mutable_version_policy() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.version_policy)
  return _internal_mutable_version_policy();
}
inline void ModelConfig::set_allocated_version_policy(::inference::ModelVersionPolicy* version_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete version_policy_;
  }
  if (version_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(version_policy);
    if (message_arena != submessage_arena) {
      version_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version_policy, submessage_arena);
    }
    
  } else {
    
  }
  version_policy_ = version_policy;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.version_policy)
}

// int32 max_batch_size = 4;
inline void ModelConfig::clear_max_batch_size() {
  max_batch_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelConfig::_internal_max_batch_size() const {
  return max_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelConfig::max_batch_size() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.max_batch_size)
  return _internal_max_batch_size();
}
inline void ModelConfig::_internal_set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_batch_size_ = value;
}
inline void ModelConfig::set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_batch_size(value);
  // @@protoc_insertion_point(field_set:inference.ModelConfig.max_batch_size)
}

// repeated .inference.ModelInput input = 5;
inline int ModelConfig::_internal_input_size() const {
  return input_.size();
}
inline int ModelConfig::input_size() const {
  return _internal_input_size();
}
inline void ModelConfig::clear_input() {
  input_.Clear();
}
inline ::inference::ModelInput* ModelConfig::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.input)
  return input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >*
ModelConfig::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.input)
  return &input_;
}
inline const ::inference::ModelInput& ModelConfig::_internal_input(int index) const {
  return input_.Get(index);
}
inline const ::inference::ModelInput& ModelConfig::input(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.input)
  return _internal_input(index);
}
inline ::inference::ModelInput* ModelConfig::_internal_add_input() {
  return input_.Add();
}
inline ::inference::ModelInput* ModelConfig::add_input() {
  // @@protoc_insertion_point(field_add:inference.ModelConfig.input)
  return _internal_add_input();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInput >&
ModelConfig::input() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.input)
  return input_;
}

// repeated .inference.ModelOutput output = 6;
inline int ModelConfig::_internal_output_size() const {
  return output_.size();
}
inline int ModelConfig::output_size() const {
  return _internal_output_size();
}
inline void ModelConfig::clear_output() {
  output_.Clear();
}
inline ::inference::ModelOutput* ModelConfig::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.output)
  return output_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >*
ModelConfig::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.output)
  return &output_;
}
inline const ::inference::ModelOutput& ModelConfig::_internal_output(int index) const {
  return output_.Get(index);
}
inline const ::inference::ModelOutput& ModelConfig::output(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.output)
  return _internal_output(index);
}
inline ::inference::ModelOutput* ModelConfig::_internal_add_output() {
  return output_.Add();
}
inline ::inference::ModelOutput* ModelConfig::add_output() {
  // @@protoc_insertion_point(field_add:inference.ModelConfig.output)
  return _internal_add_output();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelOutput >&
ModelConfig::output() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.output)
  return output_;
}

// repeated .inference.BatchInput batch_input = 20;
inline int ModelConfig::_internal_batch_input_size() const {
  return batch_input_.size();
}
inline int ModelConfig::batch_input_size() const {
  return _internal_batch_input_size();
}
inline void ModelConfig::clear_batch_input() {
  batch_input_.Clear();
}
inline ::inference::BatchInput* ModelConfig::mutable_batch_input(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.batch_input)
  return batch_input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >*
ModelConfig::mutable_batch_input() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.batch_input)
  return &batch_input_;
}
inline const ::inference::BatchInput& ModelConfig::_internal_batch_input(int index) const {
  return batch_input_.Get(index);
}
inline const ::inference::BatchInput& ModelConfig::batch_input(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.batch_input)
  return _internal_batch_input(index);
}
inline ::inference::BatchInput* ModelConfig::_internal_add_batch_input() {
  return batch_input_.Add();
}
inline ::inference::BatchInput* ModelConfig::add_batch_input() {
  // @@protoc_insertion_point(field_add:inference.ModelConfig.batch_input)
  return _internal_add_batch_input();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchInput >&
ModelConfig::batch_input() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.batch_input)
  return batch_input_;
}

// repeated .inference.BatchOutput batch_output = 21;
inline int ModelConfig::_internal_batch_output_size() const {
  return batch_output_.size();
}
inline int ModelConfig::batch_output_size() const {
  return _internal_batch_output_size();
}
inline void ModelConfig::clear_batch_output() {
  batch_output_.Clear();
}
inline ::inference::BatchOutput* ModelConfig::mutable_batch_output(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.batch_output)
  return batch_output_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >*
ModelConfig::mutable_batch_output() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.batch_output)
  return &batch_output_;
}
inline const ::inference::BatchOutput& ModelConfig::_internal_batch_output(int index) const {
  return batch_output_.Get(index);
}
inline const ::inference::BatchOutput& ModelConfig::batch_output(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.batch_output)
  return _internal_batch_output(index);
}
inline ::inference::BatchOutput* ModelConfig::_internal_add_batch_output() {
  return batch_output_.Add();
}
inline ::inference::BatchOutput* ModelConfig::add_batch_output() {
  // @@protoc_insertion_point(field_add:inference.ModelConfig.batch_output)
  return _internal_add_batch_output();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::BatchOutput >&
ModelConfig::batch_output() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.batch_output)
  return batch_output_;
}

// .inference.ModelOptimizationPolicy optimization = 12;
inline bool ModelConfig::_internal_has_optimization() const {
  return this != internal_default_instance() && optimization_ != nullptr;
}
inline bool ModelConfig::has_optimization() const {
  return _internal_has_optimization();
}
inline void ModelConfig::clear_optimization() {
  if (GetArena() == nullptr && optimization_ != nullptr) {
    delete optimization_;
  }
  optimization_ = nullptr;
}
inline const ::inference::ModelOptimizationPolicy& ModelConfig::_internal_optimization() const {
  const ::inference::ModelOptimizationPolicy* p = optimization_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOptimizationPolicy&>(
      ::inference::_ModelOptimizationPolicy_default_instance_);
}
inline const ::inference::ModelOptimizationPolicy& ModelConfig::optimization() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.optimization)
  return _internal_optimization();
}
inline void ModelConfig::unsafe_arena_set_allocated_optimization(
    ::inference::ModelOptimizationPolicy* optimization) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(optimization_);
  }
  optimization_ = optimization;
  if (optimization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.optimization)
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::release_optimization() {
  
  ::inference::ModelOptimizationPolicy* temp = optimization_;
  optimization_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::unsafe_arena_release_optimization() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.optimization)
  
  ::inference::ModelOptimizationPolicy* temp = optimization_;
  optimization_ = nullptr;
  return temp;
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::_internal_mutable_optimization() {
  
  if (optimization_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOptimizationPolicy>(GetArena());
    optimization_ = p;
  }
  return optimization_;
}
inline ::inference::ModelOptimizationPolicy* ModelConfig::mutable_optimization() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.optimization)
  return _internal_mutable_optimization();
}
inline void ModelConfig::set_allocated_optimization(::inference::ModelOptimizationPolicy* optimization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete optimization_;
  }
  if (optimization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(optimization);
    if (message_arena != submessage_arena) {
      optimization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optimization, submessage_arena);
    }
    
  } else {
    
  }
  optimization_ = optimization;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.optimization)
}

// .inference.ModelDynamicBatching dynamic_batching = 11;
inline bool ModelConfig::_internal_has_dynamic_batching() const {
  return scheduling_choice_case() == kDynamicBatching;
}
inline bool ModelConfig::has_dynamic_batching() const {
  return _internal_has_dynamic_batching();
}
inline void ModelConfig::set_has_dynamic_batching() {
  _oneof_case_[0] = kDynamicBatching;
}
inline void ModelConfig::clear_dynamic_batching() {
  if (_internal_has_dynamic_batching()) {
    if (GetArena() == nullptr) {
      delete scheduling_choice_.dynamic_batching_;
    }
    clear_has_scheduling_choice();
  }
}
inline ::inference::ModelDynamicBatching* ModelConfig::release_dynamic_batching() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.dynamic_batching)
  if (_internal_has_dynamic_batching()) {
    clear_has_scheduling_choice();
      ::inference::ModelDynamicBatching* temp = scheduling_choice_.dynamic_batching_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    scheduling_choice_.dynamic_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelDynamicBatching& ModelConfig::_internal_dynamic_batching() const {
  return _internal_has_dynamic_batching()
      ? *scheduling_choice_.dynamic_batching_
      : reinterpret_cast< ::inference::ModelDynamicBatching&>(::inference::_ModelDynamicBatching_default_instance_);
}
inline const ::inference::ModelDynamicBatching& ModelConfig::dynamic_batching() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.dynamic_batching)
  return _internal_dynamic_batching();
}
inline ::inference::ModelDynamicBatching* ModelConfig::unsafe_arena_release_dynamic_batching() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelConfig.dynamic_batching)
  if (_internal_has_dynamic_batching()) {
    clear_has_scheduling_choice();
    ::inference::ModelDynamicBatching* temp = scheduling_choice_.dynamic_batching_;
    scheduling_choice_.dynamic_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelConfig::unsafe_arena_set_allocated_dynamic_batching(::inference::ModelDynamicBatching* dynamic_batching) {
  clear_scheduling_choice();
  if (dynamic_batching) {
    set_has_dynamic_batching();
    scheduling_choice_.dynamic_batching_ = dynamic_batching;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.dynamic_batching)
}
inline ::inference::ModelDynamicBatching* ModelConfig::_internal_mutable_dynamic_batching() {
  if (!_internal_has_dynamic_batching()) {
    clear_scheduling_choice();
    set_has_dynamic_batching();
    scheduling_choice_.dynamic_batching_ = CreateMaybeMessage< ::inference::ModelDynamicBatching >(GetArena());
  }
  return scheduling_choice_.dynamic_batching_;
}
inline ::inference::ModelDynamicBatching* ModelConfig::mutable_dynamic_batching() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.dynamic_batching)
  return _internal_mutable_dynamic_batching();
}

// .inference.ModelSequenceBatching sequence_batching = 13;
inline bool ModelConfig::_internal_has_sequence_batching() const {
  return scheduling_choice_case() == kSequenceBatching;
}
inline bool ModelConfig::has_sequence_batching() const {
  return _internal_has_sequence_batching();
}
inline void ModelConfig::set_has_sequence_batching() {
  _oneof_case_[0] = kSequenceBatching;
}
inline void ModelConfig::clear_sequence_batching() {
  if (_internal_has_sequence_batching()) {
    if (GetArena() == nullptr) {
      delete scheduling_choice_.sequence_batching_;
    }
    clear_has_scheduling_choice();
  }
}
inline ::inference::ModelSequenceBatching* ModelConfig::release_sequence_batching() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.sequence_batching)
  if (_internal_has_sequence_batching()) {
    clear_has_scheduling_choice();
      ::inference::ModelSequenceBatching* temp = scheduling_choice_.sequence_batching_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    scheduling_choice_.sequence_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelSequenceBatching& ModelConfig::_internal_sequence_batching() const {
  return _internal_has_sequence_batching()
      ? *scheduling_choice_.sequence_batching_
      : reinterpret_cast< ::inference::ModelSequenceBatching&>(::inference::_ModelSequenceBatching_default_instance_);
}
inline const ::inference::ModelSequenceBatching& ModelConfig::sequence_batching() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.sequence_batching)
  return _internal_sequence_batching();
}
inline ::inference::ModelSequenceBatching* ModelConfig::unsafe_arena_release_sequence_batching() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelConfig.sequence_batching)
  if (_internal_has_sequence_batching()) {
    clear_has_scheduling_choice();
    ::inference::ModelSequenceBatching* temp = scheduling_choice_.sequence_batching_;
    scheduling_choice_.sequence_batching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelConfig::unsafe_arena_set_allocated_sequence_batching(::inference::ModelSequenceBatching* sequence_batching) {
  clear_scheduling_choice();
  if (sequence_batching) {
    set_has_sequence_batching();
    scheduling_choice_.sequence_batching_ = sequence_batching;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.sequence_batching)
}
inline ::inference::ModelSequenceBatching* ModelConfig::_internal_mutable_sequence_batching() {
  if (!_internal_has_sequence_batching()) {
    clear_scheduling_choice();
    set_has_sequence_batching();
    scheduling_choice_.sequence_batching_ = CreateMaybeMessage< ::inference::ModelSequenceBatching >(GetArena());
  }
  return scheduling_choice_.sequence_batching_;
}
inline ::inference::ModelSequenceBatching* ModelConfig::mutable_sequence_batching() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.sequence_batching)
  return _internal_mutable_sequence_batching();
}

// .inference.ModelEnsembling ensemble_scheduling = 15;
inline bool ModelConfig::_internal_has_ensemble_scheduling() const {
  return scheduling_choice_case() == kEnsembleScheduling;
}
inline bool ModelConfig::has_ensemble_scheduling() const {
  return _internal_has_ensemble_scheduling();
}
inline void ModelConfig::set_has_ensemble_scheduling() {
  _oneof_case_[0] = kEnsembleScheduling;
}
inline void ModelConfig::clear_ensemble_scheduling() {
  if (_internal_has_ensemble_scheduling()) {
    if (GetArena() == nullptr) {
      delete scheduling_choice_.ensemble_scheduling_;
    }
    clear_has_scheduling_choice();
  }
}
inline ::inference::ModelEnsembling* ModelConfig::release_ensemble_scheduling() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.ensemble_scheduling)
  if (_internal_has_ensemble_scheduling()) {
    clear_has_scheduling_choice();
      ::inference::ModelEnsembling* temp = scheduling_choice_.ensemble_scheduling_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    scheduling_choice_.ensemble_scheduling_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::inference::ModelEnsembling& ModelConfig::_internal_ensemble_scheduling() const {
  return _internal_has_ensemble_scheduling()
      ? *scheduling_choice_.ensemble_scheduling_
      : reinterpret_cast< ::inference::ModelEnsembling&>(::inference::_ModelEnsembling_default_instance_);
}
inline const ::inference::ModelEnsembling& ModelConfig::ensemble_scheduling() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.ensemble_scheduling)
  return _internal_ensemble_scheduling();
}
inline ::inference::ModelEnsembling* ModelConfig::unsafe_arena_release_ensemble_scheduling() {
  // @@protoc_insertion_point(field_unsafe_arena_release:inference.ModelConfig.ensemble_scheduling)
  if (_internal_has_ensemble_scheduling()) {
    clear_has_scheduling_choice();
    ::inference::ModelEnsembling* temp = scheduling_choice_.ensemble_scheduling_;
    scheduling_choice_.ensemble_scheduling_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ModelConfig::unsafe_arena_set_allocated_ensemble_scheduling(::inference::ModelEnsembling* ensemble_scheduling) {
  clear_scheduling_choice();
  if (ensemble_scheduling) {
    set_has_ensemble_scheduling();
    scheduling_choice_.ensemble_scheduling_ = ensemble_scheduling;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.ensemble_scheduling)
}
inline ::inference::ModelEnsembling* ModelConfig::_internal_mutable_ensemble_scheduling() {
  if (!_internal_has_ensemble_scheduling()) {
    clear_scheduling_choice();
    set_has_ensemble_scheduling();
    scheduling_choice_.ensemble_scheduling_ = CreateMaybeMessage< ::inference::ModelEnsembling >(GetArena());
  }
  return scheduling_choice_.ensemble_scheduling_;
}
inline ::inference::ModelEnsembling* ModelConfig::mutable_ensemble_scheduling() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.ensemble_scheduling)
  return _internal_mutable_ensemble_scheduling();
}

// repeated .inference.ModelInstanceGroup instance_group = 7;
inline int ModelConfig::_internal_instance_group_size() const {
  return instance_group_.size();
}
inline int ModelConfig::instance_group_size() const {
  return _internal_instance_group_size();
}
inline void ModelConfig::clear_instance_group() {
  instance_group_.Clear();
}
inline ::inference::ModelInstanceGroup* ModelConfig::mutable_instance_group(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.instance_group)
  return instance_group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >*
ModelConfig::mutable_instance_group() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.instance_group)
  return &instance_group_;
}
inline const ::inference::ModelInstanceGroup& ModelConfig::_internal_instance_group(int index) const {
  return instance_group_.Get(index);
}
inline const ::inference::ModelInstanceGroup& ModelConfig::instance_group(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.instance_group)
  return _internal_instance_group(index);
}
inline ::inference::ModelInstanceGroup* ModelConfig::_internal_add_instance_group() {
  return instance_group_.Add();
}
inline ::inference::ModelInstanceGroup* ModelConfig::add_instance_group() {
  // @@protoc_insertion_point(field_add:inference.ModelConfig.instance_group)
  return _internal_add_instance_group();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelInstanceGroup >&
ModelConfig::instance_group() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.instance_group)
  return instance_group_;
}

// string default_model_filename = 8;
inline void ModelConfig::clear_default_model_filename() {
  default_model_filename_.ClearToEmpty();
}
inline const std::string& ModelConfig::default_model_filename() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.default_model_filename)
  return _internal_default_model_filename();
}
inline void ModelConfig::set_default_model_filename(const std::string& value) {
  _internal_set_default_model_filename(value);
  // @@protoc_insertion_point(field_set:inference.ModelConfig.default_model_filename)
}
inline std::string* ModelConfig::mutable_default_model_filename() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.default_model_filename)
  return _internal_mutable_default_model_filename();
}
inline const std::string& ModelConfig::_internal_default_model_filename() const {
  return default_model_filename_.Get();
}
inline void ModelConfig::_internal_set_default_model_filename(const std::string& value) {
  
  default_model_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModelConfig::set_default_model_filename(std::string&& value) {
  
  default_model_filename_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:inference.ModelConfig.default_model_filename)
}
inline void ModelConfig::set_default_model_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  default_model_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:inference.ModelConfig.default_model_filename)
}
inline void ModelConfig::set_default_model_filename(const char* value,
    size_t size) {
  
  default_model_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:inference.ModelConfig.default_model_filename)
}
inline std::string* ModelConfig::_internal_mutable_default_model_filename() {
  
  return default_model_filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModelConfig::release_default_model_filename() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.default_model_filename)
  return default_model_filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelConfig::set_allocated_default_model_filename(std::string* default_model_filename) {
  if (default_model_filename != nullptr) {
    
  } else {
    
  }
  default_model_filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_model_filename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.default_model_filename)
}

// map<string, string> cc_model_filenames = 9;
inline int ModelConfig::_internal_cc_model_filenames_size() const {
  return cc_model_filenames_.size();
}
inline int ModelConfig::cc_model_filenames_size() const {
  return _internal_cc_model_filenames_size();
}
inline void ModelConfig::clear_cc_model_filenames() {
  cc_model_filenames_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::_internal_cc_model_filenames() const {
  return cc_model_filenames_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::cc_model_filenames() const {
  // @@protoc_insertion_point(field_map:inference.ModelConfig.cc_model_filenames)
  return _internal_cc_model_filenames();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::_internal_mutable_cc_model_filenames() {
  return cc_model_filenames_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::mutable_cc_model_filenames() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelConfig.cc_model_filenames)
  return _internal_mutable_cc_model_filenames();
}

// map<string, string> metric_tags = 10;
inline int ModelConfig::_internal_metric_tags_size() const {
  return metric_tags_.size();
}
inline int ModelConfig::metric_tags_size() const {
  return _internal_metric_tags_size();
}
inline void ModelConfig::clear_metric_tags() {
  metric_tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::_internal_metric_tags() const {
  return metric_tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ModelConfig::metric_tags() const {
  // @@protoc_insertion_point(field_map:inference.ModelConfig.metric_tags)
  return _internal_metric_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::_internal_mutable_metric_tags() {
  return metric_tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ModelConfig::mutable_metric_tags() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelConfig.metric_tags)
  return _internal_mutable_metric_tags();
}

// map<string, .inference.ModelParameter> parameters = 14;
inline int ModelConfig::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ModelConfig::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelConfig::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
ModelConfig::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >&
ModelConfig::parameters() const {
  // @@protoc_insertion_point(field_map:inference.ModelConfig.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
ModelConfig::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::inference::ModelParameter >*
ModelConfig::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:inference.ModelConfig.parameters)
  return _internal_mutable_parameters();
}

// repeated .inference.ModelWarmup model_warmup = 16;
inline int ModelConfig::_internal_model_warmup_size() const {
  return model_warmup_.size();
}
inline int ModelConfig::model_warmup_size() const {
  return _internal_model_warmup_size();
}
inline void ModelConfig::clear_model_warmup() {
  model_warmup_.Clear();
}
inline ::inference::ModelWarmup* ModelConfig::mutable_model_warmup(int index) {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.model_warmup)
  return model_warmup_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >*
ModelConfig::mutable_model_warmup() {
  // @@protoc_insertion_point(field_mutable_list:inference.ModelConfig.model_warmup)
  return &model_warmup_;
}
inline const ::inference::ModelWarmup& ModelConfig::_internal_model_warmup(int index) const {
  return model_warmup_.Get(index);
}
inline const ::inference::ModelWarmup& ModelConfig::model_warmup(int index) const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.model_warmup)
  return _internal_model_warmup(index);
}
inline ::inference::ModelWarmup* ModelConfig::_internal_add_model_warmup() {
  return model_warmup_.Add();
}
inline ::inference::ModelWarmup* ModelConfig::add_model_warmup() {
  // @@protoc_insertion_point(field_add:inference.ModelConfig.model_warmup)
  return _internal_add_model_warmup();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inference::ModelWarmup >&
ModelConfig::model_warmup() const {
  // @@protoc_insertion_point(field_list:inference.ModelConfig.model_warmup)
  return model_warmup_;
}

// .inference.ModelOperations model_operations = 18;
inline bool ModelConfig::_internal_has_model_operations() const {
  return this != internal_default_instance() && model_operations_ != nullptr;
}
inline bool ModelConfig::has_model_operations() const {
  return _internal_has_model_operations();
}
inline void ModelConfig::clear_model_operations() {
  if (GetArena() == nullptr && model_operations_ != nullptr) {
    delete model_operations_;
  }
  model_operations_ = nullptr;
}
inline const ::inference::ModelOperations& ModelConfig::_internal_model_operations() const {
  const ::inference::ModelOperations* p = model_operations_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelOperations&>(
      ::inference::_ModelOperations_default_instance_);
}
inline const ::inference::ModelOperations& ModelConfig::model_operations() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.model_operations)
  return _internal_model_operations();
}
inline void ModelConfig::unsafe_arena_set_allocated_model_operations(
    ::inference::ModelOperations* model_operations) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_operations_);
  }
  model_operations_ = model_operations;
  if (model_operations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.model_operations)
}
inline ::inference::ModelOperations* ModelConfig::release_model_operations() {
  
  ::inference::ModelOperations* temp = model_operations_;
  model_operations_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelOperations* ModelConfig::unsafe_arena_release_model_operations() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.model_operations)
  
  ::inference::ModelOperations* temp = model_operations_;
  model_operations_ = nullptr;
  return temp;
}
inline ::inference::ModelOperations* ModelConfig::_internal_mutable_model_operations() {
  
  if (model_operations_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelOperations>(GetArena());
    model_operations_ = p;
  }
  return model_operations_;
}
inline ::inference::ModelOperations* ModelConfig::mutable_model_operations() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.model_operations)
  return _internal_mutable_model_operations();
}
inline void ModelConfig::set_allocated_model_operations(::inference::ModelOperations* model_operations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete model_operations_;
  }
  if (model_operations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(model_operations);
    if (message_arena != submessage_arena) {
      model_operations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_operations, submessage_arena);
    }
    
  } else {
    
  }
  model_operations_ = model_operations;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.model_operations)
}

// .inference.ModelTransactionPolicy model_transaction_policy = 19;
inline bool ModelConfig::_internal_has_model_transaction_policy() const {
  return this != internal_default_instance() && model_transaction_policy_ != nullptr;
}
inline bool ModelConfig::has_model_transaction_policy() const {
  return _internal_has_model_transaction_policy();
}
inline void ModelConfig::clear_model_transaction_policy() {
  if (GetArena() == nullptr && model_transaction_policy_ != nullptr) {
    delete model_transaction_policy_;
  }
  model_transaction_policy_ = nullptr;
}
inline const ::inference::ModelTransactionPolicy& ModelConfig::_internal_model_transaction_policy() const {
  const ::inference::ModelTransactionPolicy* p = model_transaction_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::inference::ModelTransactionPolicy&>(
      ::inference::_ModelTransactionPolicy_default_instance_);
}
inline const ::inference::ModelTransactionPolicy& ModelConfig::model_transaction_policy() const {
  // @@protoc_insertion_point(field_get:inference.ModelConfig.model_transaction_policy)
  return _internal_model_transaction_policy();
}
inline void ModelConfig::unsafe_arena_set_allocated_model_transaction_policy(
    ::inference::ModelTransactionPolicy* model_transaction_policy) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_transaction_policy_);
  }
  model_transaction_policy_ = model_transaction_policy;
  if (model_transaction_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inference.ModelConfig.model_transaction_policy)
}
inline ::inference::ModelTransactionPolicy* ModelConfig::release_model_transaction_policy() {
  
  ::inference::ModelTransactionPolicy* temp = model_transaction_policy_;
  model_transaction_policy_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::inference::ModelTransactionPolicy* ModelConfig::unsafe_arena_release_model_transaction_policy() {
  // @@protoc_insertion_point(field_release:inference.ModelConfig.model_transaction_policy)
  
  ::inference::ModelTransactionPolicy* temp = model_transaction_policy_;
  model_transaction_policy_ = nullptr;
  return temp;
}
inline ::inference::ModelTransactionPolicy* ModelConfig::_internal_mutable_model_transaction_policy() {
  
  if (model_transaction_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::inference::ModelTransactionPolicy>(GetArena());
    model_transaction_policy_ = p;
  }
  return model_transaction_policy_;
}
inline ::inference::ModelTransactionPolicy* ModelConfig::mutable_model_transaction_policy() {
  // @@protoc_insertion_point(field_mutable:inference.ModelConfig.model_transaction_policy)
  return _internal_mutable_model_transaction_policy();
}
inline void ModelConfig::set_allocated_model_transaction_policy(::inference::ModelTransactionPolicy* model_transaction_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete model_transaction_policy_;
  }
  if (model_transaction_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(model_transaction_policy);
    if (message_arena != submessage_arena) {
      model_transaction_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_transaction_policy, submessage_arena);
    }
    
  } else {
    
  }
  model_transaction_policy_ = model_transaction_policy;
  // @@protoc_insertion_point(field_set_allocated:inference.ModelConfig.model_transaction_policy)
}

inline bool ModelConfig::has_scheduling_choice() const {
  return scheduling_choice_case() != SCHEDULING_CHOICE_NOT_SET;
}
inline void ModelConfig::clear_has_scheduling_choice() {
  _oneof_case_[0] = SCHEDULING_CHOICE_NOT_SET;
}
inline ModelConfig::SchedulingChoiceCase ModelConfig::scheduling_choice_case() const {
  return ModelConfig::SchedulingChoiceCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace inference

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::inference::ModelInstanceGroup_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelInstanceGroup_Kind>() {
  return ::inference::ModelInstanceGroup_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelInput_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelInput_Format>() {
  return ::inference::ModelInput_Format_descriptor();
}
template <> struct is_proto_enum< ::inference::BatchInput_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::BatchInput_Kind>() {
  return ::inference::BatchInput_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::BatchOutput_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::BatchOutput_Kind>() {
  return ::inference::BatchOutput_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelOptimizationPolicy_ModelPriority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelOptimizationPolicy_ModelPriority>() {
  return ::inference::ModelOptimizationPolicy_ModelPriority_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelQueuePolicy_TimeoutAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelQueuePolicy_TimeoutAction>() {
  return ::inference::ModelQueuePolicy_TimeoutAction_descriptor();
}
template <> struct is_proto_enum< ::inference::ModelSequenceBatching_Control_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::ModelSequenceBatching_Control_Kind>() {
  return ::inference::ModelSequenceBatching_Control_Kind_descriptor();
}
template <> struct is_proto_enum< ::inference::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inference::DataType>() {
  return ::inference::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_model_5fconfig_2eproto
